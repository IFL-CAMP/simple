// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSFORM_SIMPLE_H_
#define FLATBUFFERS_GENERATED_TRANSFORM_SIMPLE_H_

#include "flatbuffers/flatbuffers.h"

#include "header_generated.h"
#include "position_generated.h"

namespace simple {

struct RotationM;

struct transform;

MANUALLY_ALIGNED_STRUCT(8) RotationM FLATBUFFERS_FINAL_CLASS {
 private:
  double r11_;
  double r12_;
  double r13_;
  double r21_;
  double r22_;
  double r23_;
  double r31_;
  double r32_;
  double r33_;

 public:
  RotationM() {
    memset(this, 0, sizeof(RotationM));
  }
  RotationM(double _r11, double _r12, double _r13, double _r21, double _r22, double _r23, double _r31, double _r32, double _r33)
      : r11_(flatbuffers::EndianScalar(_r11)),
        r12_(flatbuffers::EndianScalar(_r12)),
        r13_(flatbuffers::EndianScalar(_r13)),
        r21_(flatbuffers::EndianScalar(_r21)),
        r22_(flatbuffers::EndianScalar(_r22)),
        r23_(flatbuffers::EndianScalar(_r23)),
        r31_(flatbuffers::EndianScalar(_r31)),
        r32_(flatbuffers::EndianScalar(_r32)),
        r33_(flatbuffers::EndianScalar(_r33)) {
  }
  double r11() const {
    return flatbuffers::EndianScalar(r11_);
  }
  double r12() const {
    return flatbuffers::EndianScalar(r12_);
  }
  double r13() const {
    return flatbuffers::EndianScalar(r13_);
  }
  double r21() const {
    return flatbuffers::EndianScalar(r21_);
  }
  double r22() const {
    return flatbuffers::EndianScalar(r22_);
  }
  double r23() const {
    return flatbuffers::EndianScalar(r23_);
  }
  double r31() const {
    return flatbuffers::EndianScalar(r31_);
  }
  double r32() const {
    return flatbuffers::EndianScalar(r32_);
  }
  double r33() const {
    return flatbuffers::EndianScalar(r33_);
  }
};
STRUCT_END(RotationM, 72);

struct transform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4,
    VT_ORIENTATION = 6,
    VT_HEADER = 8
  };
  uint8_t position() const {
    return GetField<uint8_t>(VT_POSITION, 0);
  }
  uint8_t orientation() const {
    return GetField<uint8_t>(VT_ORIENTATION, 0);
  }
  uint8_t Header() const {
    return GetField<uint8_t>(VT_HEADER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_ORIENTATION) &&
           VerifyField<uint8_t>(verifier, VT_HEADER) &&
           verifier.EndTable();
  }
};

struct transformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint8_t position) {
    fbb_.AddElement<uint8_t>(transform::VT_POSITION, position, 0);
  }
  void add_orientation(uint8_t orientation) {
    fbb_.AddElement<uint8_t>(transform::VT_ORIENTATION, orientation, 0);
  }
  void add_Header(uint8_t Header) {
    fbb_.AddElement<uint8_t>(transform::VT_HEADER, Header, 0);
  }
  explicit transformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  transformBuilder &operator=(const transformBuilder &);
  flatbuffers::Offset<transform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<transform>(end);
    return o;
  }
};

inline flatbuffers::Offset<transform> Createtransform(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t position = 0,
    uint8_t orientation = 0,
    uint8_t Header = 0) {
  transformBuilder builder_(_fbb);
  builder_.add_Header(Header);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  return builder_.Finish();
}

inline const simple::transform *Gettransform(const void *buf) {
  return flatbuffers::GetRoot<simple::transform>(buf);
}

inline const char *transformIdentifier() {
  return "TRFM";
}

inline bool transformBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, transformIdentifier());
}

inline bool VerifytransformBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<simple::transform>(transformIdentifier());
}

inline void FinishtransformBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<simple::transform> root) {
  fbb.Finish(root, transformIdentifier());
}

}  // namespace simple

#endif  // FLATBUFFERS_GENERATED_TRANSFORM_SIMPLE_H_
