// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_
#define FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace simple_msgs {

struct dataUInt8;

struct dataInt16;

struct dataFloat;

struct dataDouble;

struct image;

enum data {
  data_NONE = 0,
  data_dataUInt8 = 1,
  data_dataInt16 = 2,
  data_dataFloat = 3,
  data_dataDouble = 4,
  data_MIN = data_NONE,
  data_MAX = data_dataDouble
};

inline data (&EnumValuesdata())[5] {
  static data values[] = {
    data_NONE,
    data_dataUInt8,
    data_dataInt16,
    data_dataFloat,
    data_dataDouble
  };
  return values;
}

inline const char **EnumNamesdata() {
  static const char *names[] = {
    "NONE",
    "dataUInt8",
    "dataInt16",
    "dataFloat",
    "dataDouble",
    nullptr
  };
  return names;
}

inline const char *EnumNamedata(data e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesdata()[index];
}

template<typename T> struct dataTraits {
  static const data enum_value = data_NONE;
};

template<> struct dataTraits<dataUInt8> {
  static const data enum_value = data_dataUInt8;
};

template<> struct dataTraits<dataInt16> {
  static const data enum_value = data_dataInt16;
};

template<> struct dataTraits<dataFloat> {
  static const data enum_value = data_dataFloat;
};

template<> struct dataTraits<dataDouble> {
  static const data enum_value = data_dataDouble;
};

bool Verifydata(flatbuffers::Verifier &verifier, const void *obj, data type);
bool VerifydataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct dataUInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IMG = 4
  };
  uint8_t img() const {
    return GetField<uint8_t>(VT_IMG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMG) &&
           verifier.EndTable();
  }
};

struct dataUInt8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_img(uint8_t img) {
    fbb_.AddElement<uint8_t>(dataUInt8::VT_IMG, img, 0);
  }
  explicit dataUInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  dataUInt8Builder &operator=(const dataUInt8Builder &);
  flatbuffers::Offset<dataUInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<dataUInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<dataUInt8> CreatedataUInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t img = 0) {
  dataUInt8Builder builder_(_fbb);
  builder_.add_img(img);
  return builder_.Finish();
}

struct dataInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IMG = 4
  };
  int16_t img() const {
    return GetField<int16_t>(VT_IMG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_IMG) &&
           verifier.EndTable();
  }
};

struct dataInt16Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_img(int16_t img) {
    fbb_.AddElement<int16_t>(dataInt16::VT_IMG, img, 0);
  }
  explicit dataInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  dataInt16Builder &operator=(const dataInt16Builder &);
  flatbuffers::Offset<dataInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<dataInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<dataInt16> CreatedataInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t img = 0) {
  dataInt16Builder builder_(_fbb);
  builder_.add_img(img);
  return builder_.Finish();
}

struct dataFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IMG = 4
  };
  float img() const {
    return GetField<float>(VT_IMG, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_IMG) &&
           verifier.EndTable();
  }
};

struct dataFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_img(float img) {
    fbb_.AddElement<float>(dataFloat::VT_IMG, img, 0.0f);
  }
  explicit dataFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  dataFloatBuilder &operator=(const dataFloatBuilder &);
  flatbuffers::Offset<dataFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<dataFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<dataFloat> CreatedataFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float img = 0.0f) {
  dataFloatBuilder builder_(_fbb);
  builder_.add_img(img);
  return builder_.Finish();
}

struct dataDouble FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IMG = 4
  };
  double img() const {
    return GetField<double>(VT_IMG, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_IMG) &&
           verifier.EndTable();
  }
};

struct dataDoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_img(double img) {
    fbb_.AddElement<double>(dataDouble::VT_IMG, img, 0.0);
  }
  explicit dataDoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  dataDoubleBuilder &operator=(const dataDoubleBuilder &);
  flatbuffers::Offset<dataDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<dataDouble>(end);
    return o;
  }
};

inline flatbuffers::Offset<dataDouble> CreatedataDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double img = 0.0) {
  dataDoubleBuilder builder_(_fbb);
  builder_.add_img(img);
  return builder_.Finish();
}

struct image FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENCONDING = 4,
    VT_ORIGIN = 6,
    VT_RESX = 8,
    VT_RESY = 10,
    VT_RESZ = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_DEPTH = 18,
    VT_IMGDATA_TYPE = 20,
    VT_IMGDATA = 22,
    VT_HEADER = 24
  };
  const flatbuffers::String *enconding() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCONDING);
  }
  uint8_t origin() const {
    return GetField<uint8_t>(VT_ORIGIN, 0);
  }
  int32_t resX() const {
    return GetField<int32_t>(VT_RESX, 0);
  }
  int32_t resY() const {
    return GetField<int32_t>(VT_RESY, 0);
  }
  int32_t resZ() const {
    return GetField<int32_t>(VT_RESZ, 0);
  }
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  double depth() const {
    return GetField<double>(VT_DEPTH, 0.0);
  }
  data imgData_type() const {
    return static_cast<data>(GetField<uint8_t>(VT_IMGDATA_TYPE, 0));
  }
  const void *imgData() const {
    return GetPointer<const void *>(VT_IMGDATA);
  }
  template<typename T> const T *imgData_as() const;
  const dataUInt8 *imgData_as_dataUInt8() const {
    return imgData_type() == data_dataUInt8 ? static_cast<const dataUInt8 *>(imgData()) : nullptr;
  }
  const dataInt16 *imgData_as_dataInt16() const {
    return imgData_type() == data_dataInt16 ? static_cast<const dataInt16 *>(imgData()) : nullptr;
  }
  const dataFloat *imgData_as_dataFloat() const {
    return imgData_type() == data_dataFloat ? static_cast<const dataFloat *>(imgData()) : nullptr;
  }
  const dataDouble *imgData_as_dataDouble() const {
    return imgData_type() == data_dataDouble ? static_cast<const dataDouble *>(imgData()) : nullptr;
  }
  uint8_t Header() const {
    return GetField<uint8_t>(VT_HEADER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENCONDING) &&
           verifier.Verify(enconding()) &&
           VerifyField<uint8_t>(verifier, VT_ORIGIN) &&
           VerifyField<int32_t>(verifier, VT_RESX) &&
           VerifyField<int32_t>(verifier, VT_RESY) &&
           VerifyField<int32_t>(verifier, VT_RESZ) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyField<double>(verifier, VT_HEIGHT) &&
           VerifyField<double>(verifier, VT_DEPTH) &&
           VerifyField<uint8_t>(verifier, VT_IMGDATA_TYPE) &&
           VerifyOffset(verifier, VT_IMGDATA) &&
           Verifydata(verifier, imgData(), imgData_type()) &&
           VerifyField<uint8_t>(verifier, VT_HEADER) &&
           verifier.EndTable();
  }
};

template<> inline const dataUInt8 *image::imgData_as<dataUInt8>() const {
  return imgData_as_dataUInt8();
}

template<> inline const dataInt16 *image::imgData_as<dataInt16>() const {
  return imgData_as_dataInt16();
}

template<> inline const dataFloat *image::imgData_as<dataFloat>() const {
  return imgData_as_dataFloat();
}

template<> inline const dataDouble *image::imgData_as<dataDouble>() const {
  return imgData_as_dataDouble();
}

struct imageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enconding(flatbuffers::Offset<flatbuffers::String> enconding) {
    fbb_.AddOffset(image::VT_ENCONDING, enconding);
  }
  void add_origin(uint8_t origin) {
    fbb_.AddElement<uint8_t>(image::VT_ORIGIN, origin, 0);
  }
  void add_resX(int32_t resX) {
    fbb_.AddElement<int32_t>(image::VT_RESX, resX, 0);
  }
  void add_resY(int32_t resY) {
    fbb_.AddElement<int32_t>(image::VT_RESY, resY, 0);
  }
  void add_resZ(int32_t resZ) {
    fbb_.AddElement<int32_t>(image::VT_RESZ, resZ, 0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(image::VT_WIDTH, width, 0.0);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(image::VT_HEIGHT, height, 0.0);
  }
  void add_depth(double depth) {
    fbb_.AddElement<double>(image::VT_DEPTH, depth, 0.0);
  }
  void add_imgData_type(data imgData_type) {
    fbb_.AddElement<uint8_t>(image::VT_IMGDATA_TYPE, static_cast<uint8_t>(imgData_type), 0);
  }
  void add_imgData(flatbuffers::Offset<void> imgData) {
    fbb_.AddOffset(image::VT_IMGDATA, imgData);
  }
  void add_Header(uint8_t Header) {
    fbb_.AddElement<uint8_t>(image::VT_HEADER, Header, 0);
  }
  explicit imageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  imageBuilder &operator=(const imageBuilder &);
  flatbuffers::Offset<image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<image>(end);
    return o;
  }
};

inline flatbuffers::Offset<image> Createimage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> enconding = 0,
    uint8_t origin = 0,
    int32_t resX = 0,
    int32_t resY = 0,
    int32_t resZ = 0,
    double width = 0.0,
    double height = 0.0,
    double depth = 0.0,
    data imgData_type = data_NONE,
    flatbuffers::Offset<void> imgData = 0,
    uint8_t Header = 0) {
  imageBuilder builder_(_fbb);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_imgData(imgData);
  builder_.add_resZ(resZ);
  builder_.add_resY(resY);
  builder_.add_resX(resX);
  builder_.add_enconding(enconding);
  builder_.add_Header(Header);
  builder_.add_imgData_type(imgData_type);
  builder_.add_origin(origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<image> CreateimageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *enconding = nullptr,
    uint8_t origin = 0,
    int32_t resX = 0,
    int32_t resY = 0,
    int32_t resZ = 0,
    double width = 0.0,
    double height = 0.0,
    double depth = 0.0,
    data imgData_type = data_NONE,
    flatbuffers::Offset<void> imgData = 0,
    uint8_t Header = 0) {
  return simple_msgs::Createimage(
      _fbb,
      enconding ? _fbb.CreateString(enconding) : 0,
      origin,
      resX,
      resY,
      resZ,
      width,
      height,
      depth,
      imgData_type,
      imgData,
      Header);
}

inline bool Verifydata(flatbuffers::Verifier &verifier, const void *obj, data type) {
  switch (type) {
    case data_NONE: {
      return true;
    }
    case data_dataUInt8: {
      auto ptr = reinterpret_cast<const dataUInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_dataInt16: {
      auto ptr = reinterpret_cast<const dataInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_dataFloat: {
      auto ptr = reinterpret_cast<const dataFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_dataDouble: {
      auto ptr = reinterpret_cast<const dataDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifydataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifydata(
        verifier,  values->Get(i), types->GetEnum<data>(i))) {
      return false;
    }
  }
  return true;
}

inline const simple_msgs::image *Getimage(const void *buf) {
  return flatbuffers::GetRoot<simple_msgs::image>(buf);
}

inline const char *imageIdentifier() {
  return "IMAG";
}

inline bool imageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, imageIdentifier());
}

inline bool VerifyimageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<simple_msgs::image>(imageIdentifier());
}

inline void FinishimageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<simple_msgs::image> root) {
  fbb.Finish(root, imageIdentifier());
}

}  // namespace simple_msgs

#endif  // FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_
