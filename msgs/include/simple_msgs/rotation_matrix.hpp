/**
 * S.I.M.P.L.E. - Smart Intuitive Messaging Platform with Less Effort
 * Copyright (C) 2018 Salvatore Virga - salvo.virga@tum.de, Fernanda Levy
 * Langsch - fernanda.langsch@tum.de
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#ifndef SIMPLE_MSGS_ROTATION_MATRIX_H
#define SIMPLE_MSGS_ROTATION_MATRIX_H

#include <array>
#include <mutex>
#include <ostream>

#include "generic_message.hpp"

namespace simple_msgs {
/**
 * @class RotationMatrix rotation_matrix.hpp.
 * @brief A thread-safe wrapper for a Flatbuffers RotationMatrix message.
 * It represents a 3x3 rotation matrix stored in <b>row-major</b> order.
 */
class RotationMatrix : public GenericMessage {
public:
  RotationMatrix() = default;

  /**
   * @brief Construct a RotationMatrix message, all matrix values are set to the given parameter.
   */
  RotationMatrix(double value);

  /**
   * @brief Construct a RotationMatrix message using the given parameters.
   */
  RotationMatrix(double r11, double r12, double r13, double r21, double r22, double r23, double r31, double r32,
                 double r33);

  /**
   * @brief Copy construct a RotationMatrix message using the given 9D array.
   */
  RotationMatrix(const std::array<double, 9>& array);

  /**
   * @brief Move construct a RotationMatrix message using the given 9D array.
   */
  RotationMatrix(std::array<double, 9>&& array) noexcept;

  /**
   * @brief Copy constructor.
   */
  RotationMatrix(const RotationMatrix& other);

  /**
   * @brief Move constructor.
   */
  RotationMatrix(RotationMatrix&& other) noexcept;

  /**
   * @brief Copy assignment operator.
   */
  RotationMatrix& operator=(const RotationMatrix& rhs);

  /**
   * @brief Move assignment operator.
   */
  RotationMatrix& operator=(RotationMatrix&& rhs) noexcept;

  /**
   * @brief Copy assignment from a 9D array.
   */
  RotationMatrix& operator=(const std::array<double, 9>& rhs);

  /**
   * @brief Move assignment from a 9D array.
   */
  RotationMatrix& operator=(std::array<double, 9>&& rhs) noexcept;

  /**
   * @brief Returns true if lhs is equal to rhs, false otherwise.
   */
  inline bool operator==(const RotationMatrix& rhs) const {
    std::lock(mutex_, rhs.mutex_);
    std::lock_guard<std::mutex> lock{mutex_, std::adopt_lock};
    std::lock_guard<std::mutex> other_lock{rhs.mutex_, std::adopt_lock};
    return data_ == rhs.data_;
  }

  /**
   * @brief Returns true if lhs is not equal to rhs, false otherwise.
   */
  inline bool operator!=(const RotationMatrix& rhs) const { return !(*this == rhs); }

  /**
   * @brief Stream extraction operator.
   */
  friend std::ostream& operator<<(std::ostream& out, const RotationMatrix& matrix);

  /**
   * @brief Returns the rotation matrix as a linearized array.
   */
  inline std::array<double, 9> toVector() const {
    std::lock_guard<std::mutex> lock{mutex_};
    return data_;
  }
  /**
   * @brief Returns the matrix transpose.
   */
  RotationMatrix getTranspose() const;

  /**
   * @brief Returns a row of the matrix.
   * @param [in] row_index: index of the row to return in the range [0, 2].
   */
  std::array<double, 3> getRow(size_t row_index) const;

  /**
   * @brief Returns a column of the matrix.
   * @param [in] column_index: index of the column to return in the range [0, 2].
   */
  std::array<double, 3> getColumn(size_t column_index) const;

  /**
   * @brief Mofidies a row of the matrix with the given elements.
   * @param [in] row_index: index of the row to modify in the range [0, 2].
   * @param [in] values: 3D array containing the row values.

   */
  void setRow(size_t row_index, const std::array<double, 3>& values);

  /**
   * @brief Mofidies a column of the matrix with the given elements.
   * @param [in] column_index: index of the column to modify in the range [0, 2].
   * @param [in] values: 3D array containing the column values.
   */
  void setColumn(size_t column_index, const std::array<double, 3>& values);

  /**
   * @brief Rerturns an identifier of the message type generated by the flatbuffers.
   */
  static std::string getTopic();

  /**
   * @brief Returns a 3x3 identity matrix.
   */
  static inline const RotationMatrix& Identity() {
    static const RotationMatrix identity{1, 0, 0, 0, 1, 0, 0, 0, 1};
    return identity;
  }

protected:
  /**
   * @brief Construct a RotationMatrix message using a raw memory coming from network.
   */
  RotationMatrix(const void* data);

  /**
   * @brief Copy assignment operator that uses raw memory coming from the network.
   */
  RotationMatrix& operator=(std::shared_ptr<void*> rhs) override;

  /**
   * @brief Builds and returns the buffer accordingly to the values currently stored.
   */
  std::shared_ptr<flatbuffers::DetachedBuffer> getBufferData() const override;

  friend class RotationMatrixStamped;
  friend class Transform;

private:
  //! Thread safe copy and move constructors.
  RotationMatrix(const RotationMatrix& other, const std::lock_guard<std::mutex>&);
  RotationMatrix(RotationMatrix&& other, const std::lock_guard<std::mutex>&) noexcept;

  mutable std::mutex mutex_{};
  std::array<double, 9> data_{{0, 0, 0, 0, 0, 0, 0, 0, 0}};
};
}  // Namespace simple_msgs.

#endif  // SIMPLE_MSGS_ROTATION_MATRIX_H
