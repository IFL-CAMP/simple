#pragma once

#include "generic_message.h"
#include "double_generated.h"

namespace simple_msgs
{
template <typename T>
class NumericType : public GenericMessage
{
public:
  NumericType()
    : GenericMessage()
  {
  }

  /**
   * @brief Constructor from the individual data.
   */
  NumericType(T data)
    : data_(data)
  {
  }

  /**
   * @brief Constructor from the buffer data.
   * @param data acquired from flatbuffer.
   */
  NumericType(const uint8_t* data);

  /**
   * @brief Copy constructor.
   */
  NumericType(const NumericType& number)
    : NumericType(number.data_)
  {
  }

  /**
   * @brief Copy assignment.
   */
  NumericType& operator=(const NumericType& rhs)
  {
    if (this != std::addressof(rhs))
    {
      data_ = rhs.data_;
    }
    return *this;
  }

  /**
   * @brief operator==
   */
  bool operator==(const NumericType& rhs) const { return data_ == rhs.data_; }

  /**
   * @brief operator!=
   */
  bool operator!=(const NumericType& rhs) const { return !(*this == rhs); }

  /**
   * @brief Builds and returns the buffer accordingly to the values currently stored.
   * @return the buffer data.
   */
  uint8_t* getBufferData() const;

  /**
   * @brief Set the double value.
   */
  void set(T data);

  /**
   * @brief Get the double value.
   */
  T get() const { return data_; }

  /**
   * @brief Rerturns an identifier of the message type generated by the flatbuffers.
   */
  static const char* getTopic();

  template <typename Tn>
  friend std::ostream& operator<<(std::ostream& out, const NumericType<Tn>& obj);

private:
  T data_;
};

template <typename T>
std::ostream& operator<<(std::ostream& out, const NumericType<T>& obj)
{
  out << obj.data_;
  return out;
}
}  // Namespace simple_msgs.
