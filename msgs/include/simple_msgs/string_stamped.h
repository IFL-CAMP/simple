#pragma once

#include "generic_message.h"
#include "string.h"
#include "header.h"
#include "generated/string_stamped_generated.h"

namespace simple_msgs
{
class StringStamped : public GenericMessage
{
public:
  // Constructors,
  StringStamped();
  StringStamped(String, Header);
  StringStamped(const uint8_t*);
  StringStamped(const StringStamped&);
  StringStamped(StringStamped&&);

  // Copy operations.
  StringStamped& operator=(const StringStamped&);
  StringStamped& operator=(StringStamped&&) noexcept;

  // Relational operators.
  inline bool operator==(const StringStamped&) const;
  inline bool operator!=(const StringStamped&) const;

  // Binary arithmetic operators
  StringStamped& operator+=(const StringStamped&);
  friend StringStamped operator+(StringStamped, const StringStamped&);

  // Stream extraction.
  friend std::ostream& operator<<(std::ostream& out, const StringStamped& s);

  /**
   * @brief Builds and returns the buffer accordingly to the values currently stored.
   */
  uint8_t* getBufferData() const;

  /**
   * @brief Returns the string.
   */
  inline String getString() const { return data_; }

  /**
  * @brief Returns the header.
  */
  inline Header getHeader() const { return header_; }

  /**
   * @brief Modifies the string information contained in the message.
   */
  inline void setString(const String& data) { data_ = data; }

  /**
   * @brief Set the content to an empty string.
   */
  inline void setHeader(const Header& header) { header_ = header; }
  /**
   * @brief Returns an identifier of the message type generated by the flatbuffers.
   */
  static inline const char* getTopic() { return StringStampedFbsIdentifier(); }

private:
  String data_{};
  Header header_{};
};
}  // Namespace simple_msgs.
