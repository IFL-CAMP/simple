// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SIMPLE.proto

#ifndef PROTOBUF_SIMPLE_2eproto__INCLUDED
#define PROTOBUF_SIMPLE_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_SIMPLE_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsBASEMSGImpl();
void InitDefaultsBASEMSG();
void InitDefaultsHEADERImpl();
void InitDefaultsHEADER();
void InitDefaultsSTATUSImpl();
void InitDefaultsSTATUS();
void InitDefaultsCAPABILITYImpl();
void InitDefaultsCAPABILITY();
void InitDefaultsPosImpl();
void InitDefaultsPos();
void InitDefaultsOrientationImpl();
void InitDefaultsOrientation();
void InitDefaultsQuaternionImpl();
void InitDefaultsQuaternion();
void InitDefaultsPOSITIONImpl();
void InitDefaultsPOSITION();
void InitDefaultsTRANSFORMImpl();
void InitDefaultsTRANSFORM();
void InitDefaultsIMAGE_METRICSImpl();
void InitDefaultsIMAGE_METRICS();
void InitDefaultsIMAGE_SUBVOLUMEImpl();
void InitDefaultsIMAGE_SUBVOLUME();
void InitDefaultsIMAGE_imageArrayImpl();
void InitDefaultsIMAGE_imageArray();
void InitDefaultsIMAGEImpl();
void InitDefaultsIMAGE();
void InitDefaultsGENERICImpl();
void InitDefaultsGENERIC();
inline void InitDefaults() {
  InitDefaultsBASEMSG();
  InitDefaultsHEADER();
  InitDefaultsSTATUS();
  InitDefaultsCAPABILITY();
  InitDefaultsPos();
  InitDefaultsOrientation();
  InitDefaultsQuaternion();
  InitDefaultsPOSITION();
  InitDefaultsTRANSFORM();
  InitDefaultsIMAGE_METRICS();
  InitDefaultsIMAGE_SUBVOLUME();
  InitDefaultsIMAGE_imageArray();
  InitDefaultsIMAGE();
  InitDefaultsGENERIC();
}
}  // namespace protobuf_SIMPLE_2eproto
namespace SIMPLE {
class BASEMSG;
class BASEMSGDefaultTypeInternal;
extern BASEMSGDefaultTypeInternal _BASEMSG_default_instance_;
class CAPABILITY;
class CAPABILITYDefaultTypeInternal;
extern CAPABILITYDefaultTypeInternal _CAPABILITY_default_instance_;
class GENERIC;
class GENERICDefaultTypeInternal;
extern GENERICDefaultTypeInternal _GENERIC_default_instance_;
class HEADER;
class HEADERDefaultTypeInternal;
extern HEADERDefaultTypeInternal _HEADER_default_instance_;
class IMAGE;
class IMAGEDefaultTypeInternal;
extern IMAGEDefaultTypeInternal _IMAGE_default_instance_;
class IMAGE_METRICS;
class IMAGE_METRICSDefaultTypeInternal;
extern IMAGE_METRICSDefaultTypeInternal _IMAGE_METRICS_default_instance_;
class IMAGE_SUBVOLUME;
class IMAGE_SUBVOLUMEDefaultTypeInternal;
extern IMAGE_SUBVOLUMEDefaultTypeInternal _IMAGE_SUBVOLUME_default_instance_;
class IMAGE_imageArray;
class IMAGE_imageArrayDefaultTypeInternal;
extern IMAGE_imageArrayDefaultTypeInternal _IMAGE_imageArray_default_instance_;
class Orientation;
class OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class POSITION;
class POSITIONDefaultTypeInternal;
extern POSITIONDefaultTypeInternal _POSITION_default_instance_;
class Pos;
class PosDefaultTypeInternal;
extern PosDefaultTypeInternal _Pos_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class STATUS;
class STATUSDefaultTypeInternal;
extern STATUSDefaultTypeInternal _STATUS_default_instance_;
class TRANSFORM;
class TRANSFORMDefaultTypeInternal;
extern TRANSFORMDefaultTypeInternal _TRANSFORM_default_instance_;
}  // namespace SIMPLE
namespace SIMPLE {

enum IMAGE_METRICS_COStype {
  IMAGE_METRICS_COStype_LPS = 0,
  IMAGE_METRICS_COStype_RAS = 1
};
bool IMAGE_METRICS_COStype_IsValid(int value);
const IMAGE_METRICS_COStype IMAGE_METRICS_COStype_COStype_MIN = IMAGE_METRICS_COStype_LPS;
const IMAGE_METRICS_COStype IMAGE_METRICS_COStype_COStype_MAX = IMAGE_METRICS_COStype_RAS;
const int IMAGE_METRICS_COStype_COStype_ARRAYSIZE = IMAGE_METRICS_COStype_COStype_MAX + 1;

const ::google::protobuf::EnumDescriptor* IMAGE_METRICS_COStype_descriptor();
inline const ::std::string& IMAGE_METRICS_COStype_Name(IMAGE_METRICS_COStype value) {
  return ::google::protobuf::internal::NameOfEnum(
    IMAGE_METRICS_COStype_descriptor(), value);
}
inline bool IMAGE_METRICS_COStype_Parse(
    const ::std::string& name, IMAGE_METRICS_COStype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IMAGE_METRICS_COStype>(
    IMAGE_METRICS_COStype_descriptor(), name, value);
}
enum IMAGE_METRICS_dataType {
  IMAGE_METRICS_dataType_RGB = 0,
  IMAGE_METRICS_dataType_SCALAR = 1
};
bool IMAGE_METRICS_dataType_IsValid(int value);
const IMAGE_METRICS_dataType IMAGE_METRICS_dataType_dataType_MIN = IMAGE_METRICS_dataType_RGB;
const IMAGE_METRICS_dataType IMAGE_METRICS_dataType_dataType_MAX = IMAGE_METRICS_dataType_SCALAR;
const int IMAGE_METRICS_dataType_dataType_ARRAYSIZE = IMAGE_METRICS_dataType_dataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IMAGE_METRICS_dataType_descriptor();
inline const ::std::string& IMAGE_METRICS_dataType_Name(IMAGE_METRICS_dataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IMAGE_METRICS_dataType_descriptor(), value);
}
inline bool IMAGE_METRICS_dataType_Parse(
    const ::std::string& name, IMAGE_METRICS_dataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IMAGE_METRICS_dataType>(
    IMAGE_METRICS_dataType_descriptor(), name, value);
}
// ===================================================================

class BASEMSG : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.BASEMSG) */ {
 public:
  BASEMSG();
  virtual ~BASEMSG();

  BASEMSG(const BASEMSG& from);

  inline BASEMSG& operator=(const BASEMSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BASEMSG(BASEMSG&& from) noexcept
    : BASEMSG() {
    *this = ::std::move(from);
  }

  inline BASEMSG& operator=(BASEMSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BASEMSG& default_instance();

  enum DataCase {
    kStatus = 2,
    kCapability = 3,
    kImage = 4,
    kTransform = 5,
    kPosition = 6,
    kGeneric = 7,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BASEMSG* internal_default_instance() {
    return reinterpret_cast<const BASEMSG*>(
               &_BASEMSG_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(BASEMSG* other);
  friend void swap(BASEMSG& a, BASEMSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BASEMSG* New() const PROTOBUF_FINAL { return New(NULL); }

  BASEMSG* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BASEMSG& from);
  void MergeFrom(const BASEMSG& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BASEMSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SIMPLE.HEADER header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::SIMPLE::HEADER& header() const;
  ::SIMPLE::HEADER* mutable_header();
  ::SIMPLE::HEADER* release_header();
  void set_allocated_header(::SIMPLE::HEADER* header);

  // optional .SIMPLE.STATUS status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::SIMPLE::STATUS& status() const;
  ::SIMPLE::STATUS* mutable_status();
  ::SIMPLE::STATUS* release_status();
  void set_allocated_status(::SIMPLE::STATUS* status);

  // optional .SIMPLE.CAPABILITY capability = 3;
  bool has_capability() const;
  void clear_capability();
  static const int kCapabilityFieldNumber = 3;
  const ::SIMPLE::CAPABILITY& capability() const;
  ::SIMPLE::CAPABILITY* mutable_capability();
  ::SIMPLE::CAPABILITY* release_capability();
  void set_allocated_capability(::SIMPLE::CAPABILITY* capability);

  // optional .SIMPLE.IMAGE image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  const ::SIMPLE::IMAGE& image() const;
  ::SIMPLE::IMAGE* mutable_image();
  ::SIMPLE::IMAGE* release_image();
  void set_allocated_image(::SIMPLE::IMAGE* image);

  // optional .SIMPLE.TRANSFORM transform = 5;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 5;
  const ::SIMPLE::TRANSFORM& transform() const;
  ::SIMPLE::TRANSFORM* mutable_transform();
  ::SIMPLE::TRANSFORM* release_transform();
  void set_allocated_transform(::SIMPLE::TRANSFORM* transform);

  // optional .SIMPLE.POSITION position = 6;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 6;
  const ::SIMPLE::POSITION& position() const;
  ::SIMPLE::POSITION* mutable_position();
  ::SIMPLE::POSITION* release_position();
  void set_allocated_position(::SIMPLE::POSITION* position);

  // optional .SIMPLE.GENERIC generic = 7;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 7;
  const ::SIMPLE::GENERIC& generic() const;
  ::SIMPLE::GENERIC* mutable_generic();
  ::SIMPLE::GENERIC* release_generic();
  void set_allocated_generic(::SIMPLE::GENERIC* generic);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:SIMPLE.BASEMSG)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_status();
  void set_has_capability();
  void set_has_image();
  void set_has_transform();
  void set_has_position();
  void set_has_generic();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SIMPLE::HEADER* header_;
  union DataUnion {
    DataUnion() {}
    ::SIMPLE::STATUS* status_;
    ::SIMPLE::CAPABILITY* capability_;
    ::SIMPLE::IMAGE* image_;
    ::SIMPLE::TRANSFORM* transform_;
    ::SIMPLE::POSITION* position_;
    ::SIMPLE::GENERIC* generic_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsBASEMSGImpl();
};
// -------------------------------------------------------------------

class HEADER : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.HEADER) */ {
 public:
  HEADER();
  virtual ~HEADER();

  HEADER(const HEADER& from);

  inline HEADER& operator=(const HEADER& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HEADER(HEADER&& from) noexcept
    : HEADER() {
    *this = ::std::move(from);
  }

  inline HEADER& operator=(HEADER&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HEADER& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HEADER* internal_default_instance() {
    return reinterpret_cast<const HEADER*>(
               &_HEADER_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HEADER* other);
  friend void swap(HEADER& a, HEADER& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HEADER* New() const PROTOBUF_FINAL { return New(NULL); }

  HEADER* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HEADER& from);
  void MergeFrom(const HEADER& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HEADER* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dataTypeName = 2;
  bool has_datatypename() const;
  void clear_datatypename();
  static const int kDataTypeNameFieldNumber = 2;
  const ::std::string& datatypename() const;
  void set_datatypename(const ::std::string& value);
  #if LANG_CXX11
  void set_datatypename(::std::string&& value);
  #endif
  void set_datatypename(const char* value);
  void set_datatypename(const char* value, size_t size);
  ::std::string* mutable_datatypename();
  ::std::string* release_datatypename();
  void set_allocated_datatypename(::std::string* datatypename);

  // optional string deviceName = 3;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 3;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional int64 timeStamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional int32 VersionNumber = 1;
  bool has_versionnumber() const;
  void clear_versionnumber();
  static const int kVersionNumberFieldNumber = 1;
  ::google::protobuf::int32 versionnumber() const;
  void set_versionnumber(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SIMPLE.HEADER)
 private:
  void set_has_versionnumber();
  void clear_has_versionnumber();
  void set_has_datatypename();
  void clear_has_datatypename();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr datatypename_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 versionnumber_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsHEADERImpl();
};
// -------------------------------------------------------------------

class STATUS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.STATUS) */ {
 public:
  STATUS();
  virtual ~STATUS();

  STATUS(const STATUS& from);

  inline STATUS& operator=(const STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  STATUS(STATUS&& from) noexcept
    : STATUS() {
    *this = ::std::move(from);
  }

  inline STATUS& operator=(STATUS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const STATUS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const STATUS* internal_default_instance() {
    return reinterpret_cast<const STATUS*>(
               &_STATUS_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(STATUS* other);
  friend void swap(STATUS& a, STATUS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline STATUS* New() const PROTOBUF_FINAL { return New(NULL); }

  STATUS* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const STATUS& from);
  void MergeFrom(const STATUS& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(STATUS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string errorName = 3;
  bool has_errorname() const;
  void clear_errorname();
  static const int kErrorNameFieldNumber = 3;
  const ::std::string& errorname() const;
  void set_errorname(const ::std::string& value);
  #if LANG_CXX11
  void set_errorname(::std::string&& value);
  #endif
  void set_errorname(const char* value);
  void set_errorname(const char* value, size_t size);
  ::std::string* mutable_errorname();
  ::std::string* release_errorname();
  void set_allocated_errorname(::std::string* errorname);

  // optional string errorMsg = 4;
  bool has_errormsg() const;
  void clear_errormsg();
  static const int kErrorMsgFieldNumber = 4;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errormsg(::std::string&& value);
  #endif
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // optional int64 subcode = 2;
  bool has_subcode() const;
  void clear_subcode();
  static const int kSubcodeFieldNumber = 2;
  ::google::protobuf::int64 subcode() const;
  void set_subcode(::google::protobuf::int64 value);

  // optional int32 statusCode = 1;
  bool has_statuscode() const;
  void clear_statuscode();
  static const int kStatusCodeFieldNumber = 1;
  ::google::protobuf::int32 statuscode() const;
  void set_statuscode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SIMPLE.STATUS)
 private:
  void set_has_statuscode();
  void clear_has_statuscode();
  void set_has_subcode();
  void clear_has_subcode();
  void set_has_errorname();
  void clear_has_errorname();
  void set_has_errormsg();
  void clear_has_errormsg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errorname_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  ::google::protobuf::int64 subcode_;
  ::google::protobuf::int32 statuscode_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsSTATUSImpl();
};
// -------------------------------------------------------------------

class CAPABILITY : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.CAPABILITY) */ {
 public:
  CAPABILITY();
  virtual ~CAPABILITY();

  CAPABILITY(const CAPABILITY& from);

  inline CAPABILITY& operator=(const CAPABILITY& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CAPABILITY(CAPABILITY&& from) noexcept
    : CAPABILITY() {
    *this = ::std::move(from);
  }

  inline CAPABILITY& operator=(CAPABILITY&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAPABILITY& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAPABILITY* internal_default_instance() {
    return reinterpret_cast<const CAPABILITY*>(
               &_CAPABILITY_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CAPABILITY* other);
  friend void swap(CAPABILITY& a, CAPABILITY& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAPABILITY* New() const PROTOBUF_FINAL { return New(NULL); }

  CAPABILITY* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CAPABILITY& from);
  void MergeFrom(const CAPABILITY& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CAPABILITY* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string messageName = 1;
  int messagename_size() const;
  void clear_messagename();
  static const int kMessageNameFieldNumber = 1;
  const ::std::string& messagename(int index) const;
  ::std::string* mutable_messagename(int index);
  void set_messagename(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_messagename(int index, ::std::string&& value);
  #endif
  void set_messagename(int index, const char* value);
  void set_messagename(int index, const char* value, size_t size);
  ::std::string* add_messagename();
  void add_messagename(const ::std::string& value);
  #if LANG_CXX11
  void add_messagename(::std::string&& value);
  #endif
  void add_messagename(const char* value);
  void add_messagename(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& messagename() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messagename();

  // @@protoc_insertion_point(class_scope:SIMPLE.CAPABILITY)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messagename_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsCAPABILITYImpl();
};
// -------------------------------------------------------------------

class Pos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.Pos) */ {
 public:
  Pos();
  virtual ~Pos();

  Pos(const Pos& from);

  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pos(Pos&& from) noexcept
    : Pos() {
    *this = ::std::move(from);
  }

  inline Pos& operator=(Pos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pos* internal_default_instance() {
    return reinterpret_cast<const Pos*>(
               &_Pos_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Pos* other);
  friend void swap(Pos& a, Pos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pos* New() const PROTOBUF_FINAL { return New(NULL); }

  Pos* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pos& from);
  void MergeFrom(const Pos& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double px = 1;
  bool has_px() const;
  void clear_px();
  static const int kPxFieldNumber = 1;
  double px() const;
  void set_px(double value);

  // optional double py = 2;
  bool has_py() const;
  void clear_py();
  static const int kPyFieldNumber = 2;
  double py() const;
  void set_py(double value);

  // optional double pz = 3;
  bool has_pz() const;
  void clear_pz();
  static const int kPzFieldNumber = 3;
  double pz() const;
  void set_pz(double value);

  // @@protoc_insertion_point(class_scope:SIMPLE.Pos)
 private:
  void set_has_px();
  void clear_has_px();
  void set_has_py();
  void clear_has_py();
  void set_has_pz();
  void clear_has_pz();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double px_;
  double py_;
  double pz_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsPosImpl();
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(Orientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Orientation* other);
  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Orientation* New() const PROTOBUF_FINAL { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double r11 = 1;
  bool has_r11() const;
  void clear_r11();
  static const int kR11FieldNumber = 1;
  double r11() const;
  void set_r11(double value);

  // optional double r12 = 2;
  bool has_r12() const;
  void clear_r12();
  static const int kR12FieldNumber = 2;
  double r12() const;
  void set_r12(double value);

  // optional double r13 = 3;
  bool has_r13() const;
  void clear_r13();
  static const int kR13FieldNumber = 3;
  double r13() const;
  void set_r13(double value);

  // optional double r21 = 4;
  bool has_r21() const;
  void clear_r21();
  static const int kR21FieldNumber = 4;
  double r21() const;
  void set_r21(double value);

  // optional double r22 = 5;
  bool has_r22() const;
  void clear_r22();
  static const int kR22FieldNumber = 5;
  double r22() const;
  void set_r22(double value);

  // optional double r23 = 6;
  bool has_r23() const;
  void clear_r23();
  static const int kR23FieldNumber = 6;
  double r23() const;
  void set_r23(double value);

  // optional double r31 = 7;
  bool has_r31() const;
  void clear_r31();
  static const int kR31FieldNumber = 7;
  double r31() const;
  void set_r31(double value);

  // optional double r32 = 8;
  bool has_r32() const;
  void clear_r32();
  static const int kR32FieldNumber = 8;
  double r32() const;
  void set_r32(double value);

  // optional double r33 = 9;
  bool has_r33() const;
  void clear_r33();
  static const int kR33FieldNumber = 9;
  double r33() const;
  void set_r33(double value);

  // @@protoc_insertion_point(class_scope:SIMPLE.Orientation)
 private:
  void set_has_r11();
  void clear_has_r11();
  void set_has_r12();
  void clear_has_r12();
  void set_has_r13();
  void clear_has_r13();
  void set_has_r21();
  void clear_has_r21();
  void set_has_r22();
  void clear_has_r22();
  void set_has_r23();
  void clear_has_r23();
  void set_has_r31();
  void clear_has_r31();
  void set_has_r32();
  void clear_has_r32();
  void set_has_r33();
  void clear_has_r33();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double r11_;
  double r12_;
  double r13_;
  double r21_;
  double r22_;
  double r23_;
  double r31_;
  double r32_;
  double r33_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsOrientationImpl();
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double qi = 1;
  bool has_qi() const;
  void clear_qi();
  static const int kQiFieldNumber = 1;
  double qi() const;
  void set_qi(double value);

  // optional double qj = 2;
  bool has_qj() const;
  void clear_qj();
  static const int kQjFieldNumber = 2;
  double qj() const;
  void set_qj(double value);

  // optional double qk = 3;
  bool has_qk() const;
  void clear_qk();
  static const int kQkFieldNumber = 3;
  double qk() const;
  void set_qk(double value);

  // optional double qr = 4;
  bool has_qr() const;
  void clear_qr();
  static const int kQrFieldNumber = 4;
  double qr() const;
  void set_qr(double value);

  // @@protoc_insertion_point(class_scope:SIMPLE.Quaternion)
 private:
  void set_has_qi();
  void clear_has_qi();
  void set_has_qj();
  void clear_has_qj();
  void set_has_qk();
  void clear_has_qk();
  void set_has_qr();
  void clear_has_qr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double qi_;
  double qj_;
  double qk_;
  double qr_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsQuaternionImpl();
};
// -------------------------------------------------------------------

class POSITION : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.POSITION) */ {
 public:
  POSITION();
  virtual ~POSITION();

  POSITION(const POSITION& from);

  inline POSITION& operator=(const POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  POSITION(POSITION&& from) noexcept
    : POSITION() {
    *this = ::std::move(from);
  }

  inline POSITION& operator=(POSITION&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POSITION& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const POSITION* internal_default_instance() {
    return reinterpret_cast<const POSITION*>(
               &_POSITION_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(POSITION* other);
  friend void swap(POSITION& a, POSITION& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline POSITION* New() const PROTOBUF_FINAL { return New(NULL); }

  POSITION* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const POSITION& from);
  void MergeFrom(const POSITION& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(POSITION* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SIMPLE.Pos position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::SIMPLE::Pos& position() const;
  ::SIMPLE::Pos* mutable_position();
  ::SIMPLE::Pos* release_position();
  void set_allocated_position(::SIMPLE::Pos* position);

  // optional .SIMPLE.Quaternion orient = 2;
  bool has_orient() const;
  void clear_orient();
  static const int kOrientFieldNumber = 2;
  const ::SIMPLE::Quaternion& orient() const;
  ::SIMPLE::Quaternion* mutable_orient();
  ::SIMPLE::Quaternion* release_orient();
  void set_allocated_orient(::SIMPLE::Quaternion* orient);

  // @@protoc_insertion_point(class_scope:SIMPLE.POSITION)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_orient();
  void clear_has_orient();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SIMPLE::Pos* position_;
  ::SIMPLE::Quaternion* orient_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsPOSITIONImpl();
};
// -------------------------------------------------------------------

class TRANSFORM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.TRANSFORM) */ {
 public:
  TRANSFORM();
  virtual ~TRANSFORM();

  TRANSFORM(const TRANSFORM& from);

  inline TRANSFORM& operator=(const TRANSFORM& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TRANSFORM(TRANSFORM&& from) noexcept
    : TRANSFORM() {
    *this = ::std::move(from);
  }

  inline TRANSFORM& operator=(TRANSFORM&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRANSFORM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TRANSFORM* internal_default_instance() {
    return reinterpret_cast<const TRANSFORM*>(
               &_TRANSFORM_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TRANSFORM* other);
  friend void swap(TRANSFORM& a, TRANSFORM& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TRANSFORM* New() const PROTOBUF_FINAL { return New(NULL); }

  TRANSFORM* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TRANSFORM& from);
  void MergeFrom(const TRANSFORM& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TRANSFORM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SIMPLE.Pos position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::SIMPLE::Pos& position() const;
  ::SIMPLE::Pos* mutable_position();
  ::SIMPLE::Pos* release_position();
  void set_allocated_position(::SIMPLE::Pos* position);

  // optional .SIMPLE.Orientation orient = 2;
  bool has_orient() const;
  void clear_orient();
  static const int kOrientFieldNumber = 2;
  const ::SIMPLE::Orientation& orient() const;
  ::SIMPLE::Orientation* mutable_orient();
  ::SIMPLE::Orientation* release_orient();
  void set_allocated_orient(::SIMPLE::Orientation* orient);

  // @@protoc_insertion_point(class_scope:SIMPLE.TRANSFORM)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_orient();
  void clear_has_orient();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SIMPLE::Pos* position_;
  ::SIMPLE::Orientation* orient_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsTRANSFORMImpl();
};
// -------------------------------------------------------------------

class IMAGE_METRICS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.IMAGE.METRICS) */ {
 public:
  IMAGE_METRICS();
  virtual ~IMAGE_METRICS();

  IMAGE_METRICS(const IMAGE_METRICS& from);

  inline IMAGE_METRICS& operator=(const IMAGE_METRICS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMAGE_METRICS(IMAGE_METRICS&& from) noexcept
    : IMAGE_METRICS() {
    *this = ::std::move(from);
  }

  inline IMAGE_METRICS& operator=(IMAGE_METRICS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMAGE_METRICS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMAGE_METRICS* internal_default_instance() {
    return reinterpret_cast<const IMAGE_METRICS*>(
               &_IMAGE_METRICS_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(IMAGE_METRICS* other);
  friend void swap(IMAGE_METRICS& a, IMAGE_METRICS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMAGE_METRICS* New() const PROTOBUF_FINAL { return New(NULL); }

  IMAGE_METRICS* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMAGE_METRICS& from);
  void MergeFrom(const IMAGE_METRICS& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMAGE_METRICS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef IMAGE_METRICS_COStype COStype;
  static const COStype LPS =
    IMAGE_METRICS_COStype_LPS;
  static const COStype RAS =
    IMAGE_METRICS_COStype_RAS;
  static inline bool COStype_IsValid(int value) {
    return IMAGE_METRICS_COStype_IsValid(value);
  }
  static const COStype COStype_MIN =
    IMAGE_METRICS_COStype_COStype_MIN;
  static const COStype COStype_MAX =
    IMAGE_METRICS_COStype_COStype_MAX;
  static const int COStype_ARRAYSIZE =
    IMAGE_METRICS_COStype_COStype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COStype_descriptor() {
    return IMAGE_METRICS_COStype_descriptor();
  }
  static inline const ::std::string& COStype_Name(COStype value) {
    return IMAGE_METRICS_COStype_Name(value);
  }
  static inline bool COStype_Parse(const ::std::string& name,
      COStype* value) {
    return IMAGE_METRICS_COStype_Parse(name, value);
  }

  typedef IMAGE_METRICS_dataType dataType;
  static const dataType RGB =
    IMAGE_METRICS_dataType_RGB;
  static const dataType SCALAR =
    IMAGE_METRICS_dataType_SCALAR;
  static inline bool dataType_IsValid(int value) {
    return IMAGE_METRICS_dataType_IsValid(value);
  }
  static const dataType dataType_MIN =
    IMAGE_METRICS_dataType_dataType_MIN;
  static const dataType dataType_MAX =
    IMAGE_METRICS_dataType_dataType_MAX;
  static const int dataType_ARRAYSIZE =
    IMAGE_METRICS_dataType_dataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  dataType_descriptor() {
    return IMAGE_METRICS_dataType_descriptor();
  }
  static inline const ::std::string& dataType_Name(dataType value) {
    return IMAGE_METRICS_dataType_Name(value);
  }
  static inline bool dataType_Parse(const ::std::string& name,
      dataType* value) {
    return IMAGE_METRICS_dataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SIMPLE.Pos position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::SIMPLE::Pos& position() const;
  ::SIMPLE::Pos* mutable_position();
  ::SIMPLE::Pos* release_position();
  void set_allocated_position(::SIMPLE::Pos* position);

  // optional .SIMPLE.Orientation orient = 4;
  bool has_orient() const;
  void clear_orient();
  static const int kOrientFieldNumber = 4;
  const ::SIMPLE::Orientation& orient() const;
  ::SIMPLE::Orientation* mutable_orient();
  ::SIMPLE::Orientation* release_orient();
  void set_allocated_orient(::SIMPLE::Orientation* orient);

  // optional double voxelSize = 1;
  bool has_voxelsize() const;
  void clear_voxelsize();
  static const int kVoxelSizeFieldNumber = 1;
  double voxelsize() const;
  void set_voxelsize(double value);

  // optional .SIMPLE.IMAGE.METRICS.COStype COS = 2;
  bool has_cos() const;
  void clear_cos();
  static const int kCOSFieldNumber = 2;
  ::SIMPLE::IMAGE_METRICS_COStype cos() const;
  void set_cos(::SIMPLE::IMAGE_METRICS_COStype value);

  // optional int32 matrixSizeX = 5;
  bool has_matrixsizex() const;
  void clear_matrixsizex();
  static const int kMatrixSizeXFieldNumber = 5;
  ::google::protobuf::int32 matrixsizex() const;
  void set_matrixsizex(::google::protobuf::int32 value);

  // optional int32 matrixSizeY = 6;
  bool has_matrixsizey() const;
  void clear_matrixsizey();
  static const int kMatrixSizeYFieldNumber = 6;
  ::google::protobuf::int32 matrixsizey() const;
  void set_matrixsizey(::google::protobuf::int32 value);

  // optional int32 matrixSizeZ = 7;
  bool has_matrixsizez() const;
  void clear_matrixsizez();
  static const int kMatrixSizeZFieldNumber = 7;
  ::google::protobuf::int32 matrixsizez() const;
  void set_matrixsizez(::google::protobuf::int32 value);

  // optional .SIMPLE.IMAGE.METRICS.dataType type = 8;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::SIMPLE::IMAGE_METRICS_dataType type() const;
  void set_type(::SIMPLE::IMAGE_METRICS_dataType value);

  // @@protoc_insertion_point(class_scope:SIMPLE.IMAGE.METRICS)
 private:
  void set_has_voxelsize();
  void clear_has_voxelsize();
  void set_has_cos();
  void clear_has_cos();
  void set_has_position();
  void clear_has_position();
  void set_has_orient();
  void clear_has_orient();
  void set_has_matrixsizex();
  void clear_has_matrixsizex();
  void set_has_matrixsizey();
  void clear_has_matrixsizey();
  void set_has_matrixsizez();
  void clear_has_matrixsizez();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SIMPLE::Pos* position_;
  ::SIMPLE::Orientation* orient_;
  double voxelsize_;
  int cos_;
  ::google::protobuf::int32 matrixsizex_;
  ::google::protobuf::int32 matrixsizey_;
  ::google::protobuf::int32 matrixsizez_;
  int type_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsIMAGE_METRICSImpl();
};
// -------------------------------------------------------------------

class IMAGE_SUBVOLUME : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.IMAGE.SUBVOLUME) */ {
 public:
  IMAGE_SUBVOLUME();
  virtual ~IMAGE_SUBVOLUME();

  IMAGE_SUBVOLUME(const IMAGE_SUBVOLUME& from);

  inline IMAGE_SUBVOLUME& operator=(const IMAGE_SUBVOLUME& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMAGE_SUBVOLUME(IMAGE_SUBVOLUME&& from) noexcept
    : IMAGE_SUBVOLUME() {
    *this = ::std::move(from);
  }

  inline IMAGE_SUBVOLUME& operator=(IMAGE_SUBVOLUME&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMAGE_SUBVOLUME& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMAGE_SUBVOLUME* internal_default_instance() {
    return reinterpret_cast<const IMAGE_SUBVOLUME*>(
               &_IMAGE_SUBVOLUME_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(IMAGE_SUBVOLUME* other);
  friend void swap(IMAGE_SUBVOLUME& a, IMAGE_SUBVOLUME& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMAGE_SUBVOLUME* New() const PROTOBUF_FINAL { return New(NULL); }

  IMAGE_SUBVOLUME* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMAGE_SUBVOLUME& from);
  void MergeFrom(const IMAGE_SUBVOLUME& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMAGE_SUBVOLUME* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cornerVoxelIdxX = 1;
  bool has_cornervoxelidxx() const;
  void clear_cornervoxelidxx();
  static const int kCornerVoxelIdxXFieldNumber = 1;
  ::google::protobuf::int32 cornervoxelidxx() const;
  void set_cornervoxelidxx(::google::protobuf::int32 value);

  // optional int32 cornerVoxelIdxY = 2;
  bool has_cornervoxelidxy() const;
  void clear_cornervoxelidxy();
  static const int kCornerVoxelIdxYFieldNumber = 2;
  ::google::protobuf::int32 cornervoxelidxy() const;
  void set_cornervoxelidxy(::google::protobuf::int32 value);

  // optional int32 cornerVoxelIdxZ = 3;
  bool has_cornervoxelidxz() const;
  void clear_cornervoxelidxz();
  static const int kCornerVoxelIdxZFieldNumber = 3;
  ::google::protobuf::int32 cornervoxelidxz() const;
  void set_cornervoxelidxz(::google::protobuf::int32 value);

  // optional int32 numVoxelX = 4;
  bool has_numvoxelx() const;
  void clear_numvoxelx();
  static const int kNumVoxelXFieldNumber = 4;
  ::google::protobuf::int32 numvoxelx() const;
  void set_numvoxelx(::google::protobuf::int32 value);

  // optional int32 numVoxelY = 5;
  bool has_numvoxely() const;
  void clear_numvoxely();
  static const int kNumVoxelYFieldNumber = 5;
  ::google::protobuf::int32 numvoxely() const;
  void set_numvoxely(::google::protobuf::int32 value);

  // optional int32 numVoxelZ = 6;
  bool has_numvoxelz() const;
  void clear_numvoxelz();
  static const int kNumVoxelZFieldNumber = 6;
  ::google::protobuf::int32 numvoxelz() const;
  void set_numvoxelz(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SIMPLE.IMAGE.SUBVOLUME)
 private:
  void set_has_cornervoxelidxx();
  void clear_has_cornervoxelidxx();
  void set_has_cornervoxelidxy();
  void clear_has_cornervoxelidxy();
  void set_has_cornervoxelidxz();
  void clear_has_cornervoxelidxz();
  void set_has_numvoxelx();
  void clear_has_numvoxelx();
  void set_has_numvoxely();
  void clear_has_numvoxely();
  void set_has_numvoxelz();
  void clear_has_numvoxelz();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 cornervoxelidxx_;
  ::google::protobuf::int32 cornervoxelidxy_;
  ::google::protobuf::int32 cornervoxelidxz_;
  ::google::protobuf::int32 numvoxelx_;
  ::google::protobuf::int32 numvoxely_;
  ::google::protobuf::int32 numvoxelz_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsIMAGE_SUBVOLUMEImpl();
};
// -------------------------------------------------------------------

class IMAGE_imageArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.IMAGE.imageArray) */ {
 public:
  IMAGE_imageArray();
  virtual ~IMAGE_imageArray();

  IMAGE_imageArray(const IMAGE_imageArray& from);

  inline IMAGE_imageArray& operator=(const IMAGE_imageArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMAGE_imageArray(IMAGE_imageArray&& from) noexcept
    : IMAGE_imageArray() {
    *this = ::std::move(from);
  }

  inline IMAGE_imageArray& operator=(IMAGE_imageArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMAGE_imageArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMAGE_imageArray* internal_default_instance() {
    return reinterpret_cast<const IMAGE_imageArray*>(
               &_IMAGE_imageArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(IMAGE_imageArray* other);
  friend void swap(IMAGE_imageArray& a, IMAGE_imageArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMAGE_imageArray* New() const PROTOBUF_FINAL { return New(NULL); }

  IMAGE_imageArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMAGE_imageArray& from);
  void MergeFrom(const IMAGE_imageArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMAGE_imageArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dataRed = 1;
  bool has_datared() const;
  void clear_datared();
  static const int kDataRedFieldNumber = 1;
  const ::std::string& datared() const;
  void set_datared(const ::std::string& value);
  #if LANG_CXX11
  void set_datared(::std::string&& value);
  #endif
  void set_datared(const char* value);
  void set_datared(const void* value, size_t size);
  ::std::string* mutable_datared();
  ::std::string* release_datared();
  void set_allocated_datared(::std::string* datared);

  // optional bytes dataGreen = 2;
  bool has_datagreen() const;
  void clear_datagreen();
  static const int kDataGreenFieldNumber = 2;
  const ::std::string& datagreen() const;
  void set_datagreen(const ::std::string& value);
  #if LANG_CXX11
  void set_datagreen(::std::string&& value);
  #endif
  void set_datagreen(const char* value);
  void set_datagreen(const void* value, size_t size);
  ::std::string* mutable_datagreen();
  ::std::string* release_datagreen();
  void set_allocated_datagreen(::std::string* datagreen);

  // optional bytes dataBlue = 3;
  bool has_datablue() const;
  void clear_datablue();
  static const int kDataBlueFieldNumber = 3;
  const ::std::string& datablue() const;
  void set_datablue(const ::std::string& value);
  #if LANG_CXX11
  void set_datablue(::std::string&& value);
  #endif
  void set_datablue(const char* value);
  void set_datablue(const void* value, size_t size);
  ::std::string* mutable_datablue();
  ::std::string* release_datablue();
  void set_allocated_datablue(::std::string* datablue);

  // optional bytes data = 4;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:SIMPLE.IMAGE.imageArray)
 private:
  void set_has_datared();
  void clear_has_datared();
  void set_has_datagreen();
  void clear_has_datagreen();
  void set_has_datablue();
  void clear_has_datablue();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr datared_;
  ::google::protobuf::internal::ArenaStringPtr datagreen_;
  ::google::protobuf::internal::ArenaStringPtr datablue_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsIMAGE_imageArrayImpl();
};
// -------------------------------------------------------------------

class IMAGE : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.IMAGE) */ {
 public:
  IMAGE();
  virtual ~IMAGE();

  IMAGE(const IMAGE& from);

  inline IMAGE& operator=(const IMAGE& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMAGE(IMAGE&& from) noexcept
    : IMAGE() {
    *this = ::std::move(from);
  }

  inline IMAGE& operator=(IMAGE&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMAGE& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMAGE* internal_default_instance() {
    return reinterpret_cast<const IMAGE*>(
               &_IMAGE_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(IMAGE* other);
  friend void swap(IMAGE& a, IMAGE& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMAGE* New() const PROTOBUF_FINAL { return New(NULL); }

  IMAGE* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMAGE& from);
  void MergeFrom(const IMAGE& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMAGE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef IMAGE_METRICS METRICS;
  typedef IMAGE_SUBVOLUME SUBVOLUME;
  typedef IMAGE_imageArray imageArray;

  // accessors -------------------------------------------------------

  // optional .SIMPLE.IMAGE.METRICS metric = 1;
  bool has_metric() const;
  void clear_metric();
  static const int kMetricFieldNumber = 1;
  const ::SIMPLE::IMAGE_METRICS& metric() const;
  ::SIMPLE::IMAGE_METRICS* mutable_metric();
  ::SIMPLE::IMAGE_METRICS* release_metric();
  void set_allocated_metric(::SIMPLE::IMAGE_METRICS* metric);

  // optional .SIMPLE.IMAGE.SUBVOLUME subvolume = 2;
  bool has_subvolume() const;
  void clear_subvolume();
  static const int kSubvolumeFieldNumber = 2;
  const ::SIMPLE::IMAGE_SUBVOLUME& subvolume() const;
  ::SIMPLE::IMAGE_SUBVOLUME* mutable_subvolume();
  ::SIMPLE::IMAGE_SUBVOLUME* release_subvolume();
  void set_allocated_subvolume(::SIMPLE::IMAGE_SUBVOLUME* subvolume);

  // optional .SIMPLE.IMAGE.imageArray imageData = 4;
  bool has_imagedata() const;
  void clear_imagedata();
  static const int kImageDataFieldNumber = 4;
  const ::SIMPLE::IMAGE_imageArray& imagedata() const;
  ::SIMPLE::IMAGE_imageArray* mutable_imagedata();
  ::SIMPLE::IMAGE_imageArray* release_imagedata();
  void set_allocated_imagedata(::SIMPLE::IMAGE_imageArray* imagedata);

  // optional bool existSUBVOLUME = 3;
  bool has_existsubvolume() const;
  void clear_existsubvolume();
  static const int kExistSUBVOLUMEFieldNumber = 3;
  bool existsubvolume() const;
  void set_existsubvolume(bool value);

  // @@protoc_insertion_point(class_scope:SIMPLE.IMAGE)
 private:
  void set_has_metric();
  void clear_has_metric();
  void set_has_subvolume();
  void clear_has_subvolume();
  void set_has_existsubvolume();
  void clear_has_existsubvolume();
  void set_has_imagedata();
  void clear_has_imagedata();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SIMPLE::IMAGE_METRICS* metric_;
  ::SIMPLE::IMAGE_SUBVOLUME* subvolume_;
  ::SIMPLE::IMAGE_imageArray* imagedata_;
  bool existsubvolume_;
  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsIMAGEImpl();
};
// -------------------------------------------------------------------

class GENERIC : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SIMPLE.GENERIC) */ {
 public:
  GENERIC();
  virtual ~GENERIC();

  GENERIC(const GENERIC& from);

  inline GENERIC& operator=(const GENERIC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GENERIC(GENERIC&& from) noexcept
    : GENERIC() {
    *this = ::std::move(from);
  }

  inline GENERIC& operator=(GENERIC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GENERIC& default_instance();

  enum DataCase {
    kBasicBool = 1,
    kBasicInt = 2,
    kBasicFloat = 3,
    kBasicDouble = 4,
    kBasicString = 5,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GENERIC* internal_default_instance() {
    return reinterpret_cast<const GENERIC*>(
               &_GENERIC_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(GENERIC* other);
  friend void swap(GENERIC& a, GENERIC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GENERIC* New() const PROTOBUF_FINAL { return New(NULL); }

  GENERIC* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GENERIC& from);
  void MergeFrom(const GENERIC& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GENERIC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool basicBool = 1;
  bool has_basicbool() const;
  void clear_basicbool();
  static const int kBasicBoolFieldNumber = 1;
  bool basicbool() const;
  void set_basicbool(bool value);

  // optional int32 basicInt = 2;
  bool has_basicint() const;
  void clear_basicint();
  static const int kBasicIntFieldNumber = 2;
  ::google::protobuf::int32 basicint() const;
  void set_basicint(::google::protobuf::int32 value);

  // optional float basicFloat = 3;
  bool has_basicfloat() const;
  void clear_basicfloat();
  static const int kBasicFloatFieldNumber = 3;
  float basicfloat() const;
  void set_basicfloat(float value);

  // optional double basicDouble = 4;
  bool has_basicdouble() const;
  void clear_basicdouble();
  static const int kBasicDoubleFieldNumber = 4;
  double basicdouble() const;
  void set_basicdouble(double value);

  // optional string basicString = 5;
  bool has_basicstring() const;
  void clear_basicstring();
  static const int kBasicStringFieldNumber = 5;
  const ::std::string& basicstring() const;
  void set_basicstring(const ::std::string& value);
  #if LANG_CXX11
  void set_basicstring(::std::string&& value);
  #endif
  void set_basicstring(const char* value);
  void set_basicstring(const char* value, size_t size);
  ::std::string* mutable_basicstring();
  ::std::string* release_basicstring();
  void set_allocated_basicstring(::std::string* basicstring);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:SIMPLE.GENERIC)
 private:
  void set_has_basicbool();
  void set_has_basicint();
  void set_has_basicfloat();
  void set_has_basicdouble();
  void set_has_basicstring();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union DataUnion {
    DataUnion() {}
    bool basicbool_;
    ::google::protobuf::int32 basicint_;
    float basicfloat_;
    double basicdouble_;
    ::google::protobuf::internal::ArenaStringPtr basicstring_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_SIMPLE_2eproto::TableStruct;
  friend void ::protobuf_SIMPLE_2eproto::InitDefaultsGENERICImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BASEMSG

// required .SIMPLE.HEADER header = 1;
inline bool BASEMSG::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BASEMSG::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BASEMSG::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BASEMSG::clear_header() {
  if (header_ != NULL) header_->::SIMPLE::HEADER::Clear();
  clear_has_header();
}
inline const ::SIMPLE::HEADER& BASEMSG::header() const {
  const ::SIMPLE::HEADER* p = header_;
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.header)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::HEADER*>(
      &::SIMPLE::_HEADER_default_instance_);
}
inline ::SIMPLE::HEADER* BASEMSG::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::SIMPLE::HEADER;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.header)
  return header_;
}
inline ::SIMPLE::HEADER* BASEMSG::release_header() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.header)
  clear_has_header();
  ::SIMPLE::HEADER* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BASEMSG::set_allocated_header(::SIMPLE::HEADER* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.header)
}

// optional .SIMPLE.STATUS status = 2;
inline bool BASEMSG::has_status() const {
  return data_case() == kStatus;
}
inline void BASEMSG::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void BASEMSG::clear_status() {
  if (has_status()) {
    delete data_.status_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::STATUS& BASEMSG::status() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.status)
  return has_status()
      ? *data_.status_
      : ::SIMPLE::STATUS::default_instance();
}
inline ::SIMPLE::STATUS* BASEMSG::mutable_status() {
  if (!has_status()) {
    clear_data();
    set_has_status();
    data_.status_ = new ::SIMPLE::STATUS;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.status)
  return data_.status_;
}
inline ::SIMPLE::STATUS* BASEMSG::release_status() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.status)
  if (has_status()) {
    clear_has_data();
    ::SIMPLE::STATUS* temp = data_.status_;
    data_.status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_status(::SIMPLE::STATUS* status) {
  clear_data();
  if (status) {
    set_has_status();
    data_.status_ = status;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.status)
}

// optional .SIMPLE.CAPABILITY capability = 3;
inline bool BASEMSG::has_capability() const {
  return data_case() == kCapability;
}
inline void BASEMSG::set_has_capability() {
  _oneof_case_[0] = kCapability;
}
inline void BASEMSG::clear_capability() {
  if (has_capability()) {
    delete data_.capability_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::CAPABILITY& BASEMSG::capability() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.capability)
  return has_capability()
      ? *data_.capability_
      : ::SIMPLE::CAPABILITY::default_instance();
}
inline ::SIMPLE::CAPABILITY* BASEMSG::mutable_capability() {
  if (!has_capability()) {
    clear_data();
    set_has_capability();
    data_.capability_ = new ::SIMPLE::CAPABILITY;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.capability)
  return data_.capability_;
}
inline ::SIMPLE::CAPABILITY* BASEMSG::release_capability() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.capability)
  if (has_capability()) {
    clear_has_data();
    ::SIMPLE::CAPABILITY* temp = data_.capability_;
    data_.capability_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_capability(::SIMPLE::CAPABILITY* capability) {
  clear_data();
  if (capability) {
    set_has_capability();
    data_.capability_ = capability;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.capability)
}

// optional .SIMPLE.IMAGE image = 4;
inline bool BASEMSG::has_image() const {
  return data_case() == kImage;
}
inline void BASEMSG::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void BASEMSG::clear_image() {
  if (has_image()) {
    delete data_.image_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::IMAGE& BASEMSG::image() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.image)
  return has_image()
      ? *data_.image_
      : ::SIMPLE::IMAGE::default_instance();
}
inline ::SIMPLE::IMAGE* BASEMSG::mutable_image() {
  if (!has_image()) {
    clear_data();
    set_has_image();
    data_.image_ = new ::SIMPLE::IMAGE;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.image)
  return data_.image_;
}
inline ::SIMPLE::IMAGE* BASEMSG::release_image() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.image)
  if (has_image()) {
    clear_has_data();
    ::SIMPLE::IMAGE* temp = data_.image_;
    data_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_image(::SIMPLE::IMAGE* image) {
  clear_data();
  if (image) {
    set_has_image();
    data_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.image)
}

// optional .SIMPLE.TRANSFORM transform = 5;
inline bool BASEMSG::has_transform() const {
  return data_case() == kTransform;
}
inline void BASEMSG::set_has_transform() {
  _oneof_case_[0] = kTransform;
}
inline void BASEMSG::clear_transform() {
  if (has_transform()) {
    delete data_.transform_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::TRANSFORM& BASEMSG::transform() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.transform)
  return has_transform()
      ? *data_.transform_
      : ::SIMPLE::TRANSFORM::default_instance();
}
inline ::SIMPLE::TRANSFORM* BASEMSG::mutable_transform() {
  if (!has_transform()) {
    clear_data();
    set_has_transform();
    data_.transform_ = new ::SIMPLE::TRANSFORM;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.transform)
  return data_.transform_;
}
inline ::SIMPLE::TRANSFORM* BASEMSG::release_transform() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.transform)
  if (has_transform()) {
    clear_has_data();
    ::SIMPLE::TRANSFORM* temp = data_.transform_;
    data_.transform_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_transform(::SIMPLE::TRANSFORM* transform) {
  clear_data();
  if (transform) {
    set_has_transform();
    data_.transform_ = transform;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.transform)
}

// optional .SIMPLE.POSITION position = 6;
inline bool BASEMSG::has_position() const {
  return data_case() == kPosition;
}
inline void BASEMSG::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void BASEMSG::clear_position() {
  if (has_position()) {
    delete data_.position_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::POSITION& BASEMSG::position() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.position)
  return has_position()
      ? *data_.position_
      : ::SIMPLE::POSITION::default_instance();
}
inline ::SIMPLE::POSITION* BASEMSG::mutable_position() {
  if (!has_position()) {
    clear_data();
    set_has_position();
    data_.position_ = new ::SIMPLE::POSITION;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.position)
  return data_.position_;
}
inline ::SIMPLE::POSITION* BASEMSG::release_position() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.position)
  if (has_position()) {
    clear_has_data();
    ::SIMPLE::POSITION* temp = data_.position_;
    data_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_position(::SIMPLE::POSITION* position) {
  clear_data();
  if (position) {
    set_has_position();
    data_.position_ = position;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.position)
}

// optional .SIMPLE.GENERIC generic = 7;
inline bool BASEMSG::has_generic() const {
  return data_case() == kGeneric;
}
inline void BASEMSG::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline void BASEMSG::clear_generic() {
  if (has_generic()) {
    delete data_.generic_;
    clear_has_data();
  }
}
inline  const ::SIMPLE::GENERIC& BASEMSG::generic() const {
  // @@protoc_insertion_point(field_get:SIMPLE.BASEMSG.generic)
  return has_generic()
      ? *data_.generic_
      : ::SIMPLE::GENERIC::default_instance();
}
inline ::SIMPLE::GENERIC* BASEMSG::mutable_generic() {
  if (!has_generic()) {
    clear_data();
    set_has_generic();
    data_.generic_ = new ::SIMPLE::GENERIC;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.BASEMSG.generic)
  return data_.generic_;
}
inline ::SIMPLE::GENERIC* BASEMSG::release_generic() {
  // @@protoc_insertion_point(field_release:SIMPLE.BASEMSG.generic)
  if (has_generic()) {
    clear_has_data();
    ::SIMPLE::GENERIC* temp = data_.generic_;
    data_.generic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void BASEMSG::set_allocated_generic(::SIMPLE::GENERIC* generic) {
  clear_data();
  if (generic) {
    set_has_generic();
    data_.generic_ = generic;
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.BASEMSG.generic)
}

inline bool BASEMSG::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void BASEMSG::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline BASEMSG::DataCase BASEMSG::data_case() const {
  return BASEMSG::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HEADER

// optional int32 VersionNumber = 1;
inline bool HEADER::has_versionnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HEADER::set_has_versionnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HEADER::clear_has_versionnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HEADER::clear_versionnumber() {
  versionnumber_ = 0;
  clear_has_versionnumber();
}
inline ::google::protobuf::int32 HEADER::versionnumber() const {
  // @@protoc_insertion_point(field_get:SIMPLE.HEADER.VersionNumber)
  return versionnumber_;
}
inline void HEADER::set_versionnumber(::google::protobuf::int32 value) {
  set_has_versionnumber();
  versionnumber_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.HEADER.VersionNumber)
}

// optional string dataTypeName = 2;
inline bool HEADER::has_datatypename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HEADER::set_has_datatypename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HEADER::clear_has_datatypename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HEADER::clear_datatypename() {
  datatypename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datatypename();
}
inline const ::std::string& HEADER::datatypename() const {
  // @@protoc_insertion_point(field_get:SIMPLE.HEADER.dataTypeName)
  return datatypename_.GetNoArena();
}
inline void HEADER::set_datatypename(const ::std::string& value) {
  set_has_datatypename();
  datatypename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.HEADER.dataTypeName)
}
#if LANG_CXX11
inline void HEADER::set_datatypename(::std::string&& value) {
  set_has_datatypename();
  datatypename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.HEADER.dataTypeName)
}
#endif
inline void HEADER::set_datatypename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_datatypename();
  datatypename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.HEADER.dataTypeName)
}
inline void HEADER::set_datatypename(const char* value, size_t size) {
  set_has_datatypename();
  datatypename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.HEADER.dataTypeName)
}
inline ::std::string* HEADER::mutable_datatypename() {
  set_has_datatypename();
  // @@protoc_insertion_point(field_mutable:SIMPLE.HEADER.dataTypeName)
  return datatypename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HEADER::release_datatypename() {
  // @@protoc_insertion_point(field_release:SIMPLE.HEADER.dataTypeName)
  clear_has_datatypename();
  return datatypename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HEADER::set_allocated_datatypename(::std::string* datatypename) {
  if (datatypename != NULL) {
    set_has_datatypename();
  } else {
    clear_has_datatypename();
  }
  datatypename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datatypename);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.HEADER.dataTypeName)
}

// optional string deviceName = 3;
inline bool HEADER::has_devicename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HEADER::set_has_devicename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HEADER::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HEADER::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& HEADER::devicename() const {
  // @@protoc_insertion_point(field_get:SIMPLE.HEADER.deviceName)
  return devicename_.GetNoArena();
}
inline void HEADER::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.HEADER.deviceName)
}
#if LANG_CXX11
inline void HEADER::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.HEADER.deviceName)
}
#endif
inline void HEADER::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.HEADER.deviceName)
}
inline void HEADER::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.HEADER.deviceName)
}
inline ::std::string* HEADER::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:SIMPLE.HEADER.deviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HEADER::release_devicename() {
  // @@protoc_insertion_point(field_release:SIMPLE.HEADER.deviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HEADER::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.HEADER.deviceName)
}

// optional int64 timeStamp = 4;
inline bool HEADER::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HEADER::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HEADER::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HEADER::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 HEADER::timestamp() const {
  // @@protoc_insertion_point(field_get:SIMPLE.HEADER.timeStamp)
  return timestamp_;
}
inline void HEADER::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.HEADER.timeStamp)
}

// -------------------------------------------------------------------

// STATUS

// optional int32 statusCode = 1;
inline bool STATUS::has_statuscode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void STATUS::set_has_statuscode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void STATUS::clear_has_statuscode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void STATUS::clear_statuscode() {
  statuscode_ = 0;
  clear_has_statuscode();
}
inline ::google::protobuf::int32 STATUS::statuscode() const {
  // @@protoc_insertion_point(field_get:SIMPLE.STATUS.statusCode)
  return statuscode_;
}
inline void STATUS::set_statuscode(::google::protobuf::int32 value) {
  set_has_statuscode();
  statuscode_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.STATUS.statusCode)
}

// optional int64 subcode = 2;
inline bool STATUS::has_subcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void STATUS::set_has_subcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void STATUS::clear_has_subcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void STATUS::clear_subcode() {
  subcode_ = GOOGLE_LONGLONG(0);
  clear_has_subcode();
}
inline ::google::protobuf::int64 STATUS::subcode() const {
  // @@protoc_insertion_point(field_get:SIMPLE.STATUS.subcode)
  return subcode_;
}
inline void STATUS::set_subcode(::google::protobuf::int64 value) {
  set_has_subcode();
  subcode_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.STATUS.subcode)
}

// optional string errorName = 3;
inline bool STATUS::has_errorname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void STATUS::set_has_errorname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void STATUS::clear_has_errorname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void STATUS::clear_errorname() {
  errorname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errorname();
}
inline const ::std::string& STATUS::errorname() const {
  // @@protoc_insertion_point(field_get:SIMPLE.STATUS.errorName)
  return errorname_.GetNoArena();
}
inline void STATUS::set_errorname(const ::std::string& value) {
  set_has_errorname();
  errorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.STATUS.errorName)
}
#if LANG_CXX11
inline void STATUS::set_errorname(::std::string&& value) {
  set_has_errorname();
  errorname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.STATUS.errorName)
}
#endif
inline void STATUS::set_errorname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errorname();
  errorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.STATUS.errorName)
}
inline void STATUS::set_errorname(const char* value, size_t size) {
  set_has_errorname();
  errorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.STATUS.errorName)
}
inline ::std::string* STATUS::mutable_errorname() {
  set_has_errorname();
  // @@protoc_insertion_point(field_mutable:SIMPLE.STATUS.errorName)
  return errorname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* STATUS::release_errorname() {
  // @@protoc_insertion_point(field_release:SIMPLE.STATUS.errorName)
  clear_has_errorname();
  return errorname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void STATUS::set_allocated_errorname(::std::string* errorname) {
  if (errorname != NULL) {
    set_has_errorname();
  } else {
    clear_has_errorname();
  }
  errorname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errorname);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.STATUS.errorName)
}

// optional string errorMsg = 4;
inline bool STATUS::has_errormsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void STATUS::set_has_errormsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void STATUS::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void STATUS::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormsg();
}
inline const ::std::string& STATUS::errormsg() const {
  // @@protoc_insertion_point(field_get:SIMPLE.STATUS.errorMsg)
  return errormsg_.GetNoArena();
}
inline void STATUS::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.STATUS.errorMsg)
}
#if LANG_CXX11
inline void STATUS::set_errormsg(::std::string&& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.STATUS.errorMsg)
}
#endif
inline void STATUS::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.STATUS.errorMsg)
}
inline void STATUS::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.STATUS.errorMsg)
}
inline ::std::string* STATUS::mutable_errormsg() {
  set_has_errormsg();
  // @@protoc_insertion_point(field_mutable:SIMPLE.STATUS.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* STATUS::release_errormsg() {
  // @@protoc_insertion_point(field_release:SIMPLE.STATUS.errorMsg)
  clear_has_errormsg();
  return errormsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void STATUS::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.STATUS.errorMsg)
}

// -------------------------------------------------------------------

// CAPABILITY

// repeated string messageName = 1;
inline int CAPABILITY::messagename_size() const {
  return messagename_.size();
}
inline void CAPABILITY::clear_messagename() {
  messagename_.Clear();
}
inline const ::std::string& CAPABILITY::messagename(int index) const {
  // @@protoc_insertion_point(field_get:SIMPLE.CAPABILITY.messageName)
  return messagename_.Get(index);
}
inline ::std::string* CAPABILITY::mutable_messagename(int index) {
  // @@protoc_insertion_point(field_mutable:SIMPLE.CAPABILITY.messageName)
  return messagename_.Mutable(index);
}
inline void CAPABILITY::set_messagename(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SIMPLE.CAPABILITY.messageName)
  messagename_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CAPABILITY::set_messagename(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SIMPLE.CAPABILITY.messageName)
  messagename_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CAPABILITY::set_messagename(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messagename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SIMPLE.CAPABILITY.messageName)
}
inline void CAPABILITY::set_messagename(int index, const char* value, size_t size) {
  messagename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.CAPABILITY.messageName)
}
inline ::std::string* CAPABILITY::add_messagename() {
  // @@protoc_insertion_point(field_add_mutable:SIMPLE.CAPABILITY.messageName)
  return messagename_.Add();
}
inline void CAPABILITY::add_messagename(const ::std::string& value) {
  messagename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SIMPLE.CAPABILITY.messageName)
}
#if LANG_CXX11
inline void CAPABILITY::add_messagename(::std::string&& value) {
  messagename_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SIMPLE.CAPABILITY.messageName)
}
#endif
inline void CAPABILITY::add_messagename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messagename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SIMPLE.CAPABILITY.messageName)
}
inline void CAPABILITY::add_messagename(const char* value, size_t size) {
  messagename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SIMPLE.CAPABILITY.messageName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CAPABILITY::messagename() const {
  // @@protoc_insertion_point(field_list:SIMPLE.CAPABILITY.messageName)
  return messagename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CAPABILITY::mutable_messagename() {
  // @@protoc_insertion_point(field_mutable_list:SIMPLE.CAPABILITY.messageName)
  return &messagename_;
}

// -------------------------------------------------------------------

// Pos

// optional double px = 1;
inline bool Pos::has_px() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pos::set_has_px() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pos::clear_has_px() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pos::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double Pos::px() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Pos.px)
  return px_;
}
inline void Pos::set_px(double value) {
  set_has_px();
  px_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Pos.px)
}

// optional double py = 2;
inline bool Pos::has_py() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pos::set_has_py() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pos::clear_has_py() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pos::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double Pos::py() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Pos.py)
  return py_;
}
inline void Pos::set_py(double value) {
  set_has_py();
  py_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Pos.py)
}

// optional double pz = 3;
inline bool Pos::has_pz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pos::set_has_pz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pos::clear_has_pz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pos::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double Pos::pz() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Pos.pz)
  return pz_;
}
inline void Pos::set_pz(double value) {
  set_has_pz();
  pz_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Pos.pz)
}

// -------------------------------------------------------------------

// Orientation

// optional double r11 = 1;
inline bool Orientation::has_r11() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation::set_has_r11() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orientation::clear_has_r11() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orientation::clear_r11() {
  r11_ = 0;
  clear_has_r11();
}
inline double Orientation::r11() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r11)
  return r11_;
}
inline void Orientation::set_r11(double value) {
  set_has_r11();
  r11_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r11)
}

// optional double r12 = 2;
inline bool Orientation::has_r12() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation::set_has_r12() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orientation::clear_has_r12() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orientation::clear_r12() {
  r12_ = 0;
  clear_has_r12();
}
inline double Orientation::r12() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r12)
  return r12_;
}
inline void Orientation::set_r12(double value) {
  set_has_r12();
  r12_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r12)
}

// optional double r13 = 3;
inline bool Orientation::has_r13() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation::set_has_r13() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orientation::clear_has_r13() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orientation::clear_r13() {
  r13_ = 0;
  clear_has_r13();
}
inline double Orientation::r13() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r13)
  return r13_;
}
inline void Orientation::set_r13(double value) {
  set_has_r13();
  r13_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r13)
}

// optional double r21 = 4;
inline bool Orientation::has_r21() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Orientation::set_has_r21() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Orientation::clear_has_r21() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Orientation::clear_r21() {
  r21_ = 0;
  clear_has_r21();
}
inline double Orientation::r21() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r21)
  return r21_;
}
inline void Orientation::set_r21(double value) {
  set_has_r21();
  r21_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r21)
}

// optional double r22 = 5;
inline bool Orientation::has_r22() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Orientation::set_has_r22() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Orientation::clear_has_r22() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Orientation::clear_r22() {
  r22_ = 0;
  clear_has_r22();
}
inline double Orientation::r22() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r22)
  return r22_;
}
inline void Orientation::set_r22(double value) {
  set_has_r22();
  r22_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r22)
}

// optional double r23 = 6;
inline bool Orientation::has_r23() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Orientation::set_has_r23() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Orientation::clear_has_r23() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Orientation::clear_r23() {
  r23_ = 0;
  clear_has_r23();
}
inline double Orientation::r23() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r23)
  return r23_;
}
inline void Orientation::set_r23(double value) {
  set_has_r23();
  r23_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r23)
}

// optional double r31 = 7;
inline bool Orientation::has_r31() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Orientation::set_has_r31() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Orientation::clear_has_r31() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Orientation::clear_r31() {
  r31_ = 0;
  clear_has_r31();
}
inline double Orientation::r31() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r31)
  return r31_;
}
inline void Orientation::set_r31(double value) {
  set_has_r31();
  r31_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r31)
}

// optional double r32 = 8;
inline bool Orientation::has_r32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Orientation::set_has_r32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Orientation::clear_has_r32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Orientation::clear_r32() {
  r32_ = 0;
  clear_has_r32();
}
inline double Orientation::r32() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r32)
  return r32_;
}
inline void Orientation::set_r32(double value) {
  set_has_r32();
  r32_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r32)
}

// optional double r33 = 9;
inline bool Orientation::has_r33() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Orientation::set_has_r33() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Orientation::clear_has_r33() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Orientation::clear_r33() {
  r33_ = 0;
  clear_has_r33();
}
inline double Orientation::r33() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Orientation.r33)
  return r33_;
}
inline void Orientation::set_r33(double value) {
  set_has_r33();
  r33_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Orientation.r33)
}

// -------------------------------------------------------------------

// Quaternion

// optional double qi = 1;
inline bool Quaternion::has_qi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_qi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_qi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_qi() {
  qi_ = 0;
  clear_has_qi();
}
inline double Quaternion::qi() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Quaternion.qi)
  return qi_;
}
inline void Quaternion::set_qi(double value) {
  set_has_qi();
  qi_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Quaternion.qi)
}

// optional double qj = 2;
inline bool Quaternion::has_qj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_qj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_qj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_qj() {
  qj_ = 0;
  clear_has_qj();
}
inline double Quaternion::qj() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Quaternion.qj)
  return qj_;
}
inline void Quaternion::set_qj(double value) {
  set_has_qj();
  qj_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Quaternion.qj)
}

// optional double qk = 3;
inline bool Quaternion::has_qk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_qk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_qk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_qk() {
  qk_ = 0;
  clear_has_qk();
}
inline double Quaternion::qk() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Quaternion.qk)
  return qk_;
}
inline void Quaternion::set_qk(double value) {
  set_has_qk();
  qk_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Quaternion.qk)
}

// optional double qr = 4;
inline bool Quaternion::has_qr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_qr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_qr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_qr() {
  qr_ = 0;
  clear_has_qr();
}
inline double Quaternion::qr() const {
  // @@protoc_insertion_point(field_get:SIMPLE.Quaternion.qr)
  return qr_;
}
inline void Quaternion::set_qr(double value) {
  set_has_qr();
  qr_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.Quaternion.qr)
}

// -------------------------------------------------------------------

// POSITION

// optional .SIMPLE.Pos position = 1;
inline bool POSITION::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POSITION::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POSITION::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POSITION::clear_position() {
  if (position_ != NULL) position_->::SIMPLE::Pos::Clear();
  clear_has_position();
}
inline const ::SIMPLE::Pos& POSITION::position() const {
  const ::SIMPLE::Pos* p = position_;
  // @@protoc_insertion_point(field_get:SIMPLE.POSITION.position)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Pos*>(
      &::SIMPLE::_Pos_default_instance_);
}
inline ::SIMPLE::Pos* POSITION::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::SIMPLE::Pos;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.POSITION.position)
  return position_;
}
inline ::SIMPLE::Pos* POSITION::release_position() {
  // @@protoc_insertion_point(field_release:SIMPLE.POSITION.position)
  clear_has_position();
  ::SIMPLE::Pos* temp = position_;
  position_ = NULL;
  return temp;
}
inline void POSITION::set_allocated_position(::SIMPLE::Pos* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.POSITION.position)
}

// optional .SIMPLE.Quaternion orient = 2;
inline bool POSITION::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void POSITION::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void POSITION::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void POSITION::clear_orient() {
  if (orient_ != NULL) orient_->::SIMPLE::Quaternion::Clear();
  clear_has_orient();
}
inline const ::SIMPLE::Quaternion& POSITION::orient() const {
  const ::SIMPLE::Quaternion* p = orient_;
  // @@protoc_insertion_point(field_get:SIMPLE.POSITION.orient)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Quaternion*>(
      &::SIMPLE::_Quaternion_default_instance_);
}
inline ::SIMPLE::Quaternion* POSITION::mutable_orient() {
  set_has_orient();
  if (orient_ == NULL) {
    orient_ = new ::SIMPLE::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.POSITION.orient)
  return orient_;
}
inline ::SIMPLE::Quaternion* POSITION::release_orient() {
  // @@protoc_insertion_point(field_release:SIMPLE.POSITION.orient)
  clear_has_orient();
  ::SIMPLE::Quaternion* temp = orient_;
  orient_ = NULL;
  return temp;
}
inline void POSITION::set_allocated_orient(::SIMPLE::Quaternion* orient) {
  delete orient_;
  orient_ = orient;
  if (orient) {
    set_has_orient();
  } else {
    clear_has_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.POSITION.orient)
}

// -------------------------------------------------------------------

// TRANSFORM

// optional .SIMPLE.Pos position = 1;
inline bool TRANSFORM::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TRANSFORM::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TRANSFORM::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TRANSFORM::clear_position() {
  if (position_ != NULL) position_->::SIMPLE::Pos::Clear();
  clear_has_position();
}
inline const ::SIMPLE::Pos& TRANSFORM::position() const {
  const ::SIMPLE::Pos* p = position_;
  // @@protoc_insertion_point(field_get:SIMPLE.TRANSFORM.position)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Pos*>(
      &::SIMPLE::_Pos_default_instance_);
}
inline ::SIMPLE::Pos* TRANSFORM::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::SIMPLE::Pos;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.TRANSFORM.position)
  return position_;
}
inline ::SIMPLE::Pos* TRANSFORM::release_position() {
  // @@protoc_insertion_point(field_release:SIMPLE.TRANSFORM.position)
  clear_has_position();
  ::SIMPLE::Pos* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TRANSFORM::set_allocated_position(::SIMPLE::Pos* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.TRANSFORM.position)
}

// optional .SIMPLE.Orientation orient = 2;
inline bool TRANSFORM::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TRANSFORM::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TRANSFORM::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TRANSFORM::clear_orient() {
  if (orient_ != NULL) orient_->::SIMPLE::Orientation::Clear();
  clear_has_orient();
}
inline const ::SIMPLE::Orientation& TRANSFORM::orient() const {
  const ::SIMPLE::Orientation* p = orient_;
  // @@protoc_insertion_point(field_get:SIMPLE.TRANSFORM.orient)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Orientation*>(
      &::SIMPLE::_Orientation_default_instance_);
}
inline ::SIMPLE::Orientation* TRANSFORM::mutable_orient() {
  set_has_orient();
  if (orient_ == NULL) {
    orient_ = new ::SIMPLE::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.TRANSFORM.orient)
  return orient_;
}
inline ::SIMPLE::Orientation* TRANSFORM::release_orient() {
  // @@protoc_insertion_point(field_release:SIMPLE.TRANSFORM.orient)
  clear_has_orient();
  ::SIMPLE::Orientation* temp = orient_;
  orient_ = NULL;
  return temp;
}
inline void TRANSFORM::set_allocated_orient(::SIMPLE::Orientation* orient) {
  delete orient_;
  orient_ = orient;
  if (orient) {
    set_has_orient();
  } else {
    clear_has_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.TRANSFORM.orient)
}

// -------------------------------------------------------------------

// IMAGE_METRICS

// optional double voxelSize = 1;
inline bool IMAGE_METRICS::has_voxelsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAGE_METRICS::set_has_voxelsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAGE_METRICS::clear_has_voxelsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAGE_METRICS::clear_voxelsize() {
  voxelsize_ = 0;
  clear_has_voxelsize();
}
inline double IMAGE_METRICS::voxelsize() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.voxelSize)
  return voxelsize_;
}
inline void IMAGE_METRICS::set_voxelsize(double value) {
  set_has_voxelsize();
  voxelsize_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.voxelSize)
}

// optional .SIMPLE.IMAGE.METRICS.COStype COS = 2;
inline bool IMAGE_METRICS::has_cos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAGE_METRICS::set_has_cos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAGE_METRICS::clear_has_cos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAGE_METRICS::clear_cos() {
  cos_ = 0;
  clear_has_cos();
}
inline ::SIMPLE::IMAGE_METRICS_COStype IMAGE_METRICS::cos() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.COS)
  return static_cast< ::SIMPLE::IMAGE_METRICS_COStype >(cos_);
}
inline void IMAGE_METRICS::set_cos(::SIMPLE::IMAGE_METRICS_COStype value) {
  assert(::SIMPLE::IMAGE_METRICS_COStype_IsValid(value));
  set_has_cos();
  cos_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.COS)
}

// optional .SIMPLE.Pos position = 3;
inline bool IMAGE_METRICS::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAGE_METRICS::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAGE_METRICS::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAGE_METRICS::clear_position() {
  if (position_ != NULL) position_->::SIMPLE::Pos::Clear();
  clear_has_position();
}
inline const ::SIMPLE::Pos& IMAGE_METRICS::position() const {
  const ::SIMPLE::Pos* p = position_;
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.position)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Pos*>(
      &::SIMPLE::_Pos_default_instance_);
}
inline ::SIMPLE::Pos* IMAGE_METRICS::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::SIMPLE::Pos;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.METRICS.position)
  return position_;
}
inline ::SIMPLE::Pos* IMAGE_METRICS::release_position() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.METRICS.position)
  clear_has_position();
  ::SIMPLE::Pos* temp = position_;
  position_ = NULL;
  return temp;
}
inline void IMAGE_METRICS::set_allocated_position(::SIMPLE::Pos* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.METRICS.position)
}

// optional .SIMPLE.Orientation orient = 4;
inline bool IMAGE_METRICS::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAGE_METRICS::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAGE_METRICS::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAGE_METRICS::clear_orient() {
  if (orient_ != NULL) orient_->::SIMPLE::Orientation::Clear();
  clear_has_orient();
}
inline const ::SIMPLE::Orientation& IMAGE_METRICS::orient() const {
  const ::SIMPLE::Orientation* p = orient_;
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.orient)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::Orientation*>(
      &::SIMPLE::_Orientation_default_instance_);
}
inline ::SIMPLE::Orientation* IMAGE_METRICS::mutable_orient() {
  set_has_orient();
  if (orient_ == NULL) {
    orient_ = new ::SIMPLE::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.METRICS.orient)
  return orient_;
}
inline ::SIMPLE::Orientation* IMAGE_METRICS::release_orient() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.METRICS.orient)
  clear_has_orient();
  ::SIMPLE::Orientation* temp = orient_;
  orient_ = NULL;
  return temp;
}
inline void IMAGE_METRICS::set_allocated_orient(::SIMPLE::Orientation* orient) {
  delete orient_;
  orient_ = orient;
  if (orient) {
    set_has_orient();
  } else {
    clear_has_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.METRICS.orient)
}

// optional int32 matrixSizeX = 5;
inline bool IMAGE_METRICS::has_matrixsizex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAGE_METRICS::set_has_matrixsizex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAGE_METRICS::clear_has_matrixsizex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAGE_METRICS::clear_matrixsizex() {
  matrixsizex_ = 0;
  clear_has_matrixsizex();
}
inline ::google::protobuf::int32 IMAGE_METRICS::matrixsizex() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.matrixSizeX)
  return matrixsizex_;
}
inline void IMAGE_METRICS::set_matrixsizex(::google::protobuf::int32 value) {
  set_has_matrixsizex();
  matrixsizex_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.matrixSizeX)
}

// optional int32 matrixSizeY = 6;
inline bool IMAGE_METRICS::has_matrixsizey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMAGE_METRICS::set_has_matrixsizey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMAGE_METRICS::clear_has_matrixsizey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMAGE_METRICS::clear_matrixsizey() {
  matrixsizey_ = 0;
  clear_has_matrixsizey();
}
inline ::google::protobuf::int32 IMAGE_METRICS::matrixsizey() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.matrixSizeY)
  return matrixsizey_;
}
inline void IMAGE_METRICS::set_matrixsizey(::google::protobuf::int32 value) {
  set_has_matrixsizey();
  matrixsizey_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.matrixSizeY)
}

// optional int32 matrixSizeZ = 7;
inline bool IMAGE_METRICS::has_matrixsizez() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMAGE_METRICS::set_has_matrixsizez() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMAGE_METRICS::clear_has_matrixsizez() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMAGE_METRICS::clear_matrixsizez() {
  matrixsizez_ = 0;
  clear_has_matrixsizez();
}
inline ::google::protobuf::int32 IMAGE_METRICS::matrixsizez() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.matrixSizeZ)
  return matrixsizez_;
}
inline void IMAGE_METRICS::set_matrixsizez(::google::protobuf::int32 value) {
  set_has_matrixsizez();
  matrixsizez_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.matrixSizeZ)
}

// optional .SIMPLE.IMAGE.METRICS.dataType type = 8;
inline bool IMAGE_METRICS::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMAGE_METRICS::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMAGE_METRICS::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMAGE_METRICS::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SIMPLE::IMAGE_METRICS_dataType IMAGE_METRICS::type() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.METRICS.type)
  return static_cast< ::SIMPLE::IMAGE_METRICS_dataType >(type_);
}
inline void IMAGE_METRICS::set_type(::SIMPLE::IMAGE_METRICS_dataType value) {
  assert(::SIMPLE::IMAGE_METRICS_dataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.METRICS.type)
}

// -------------------------------------------------------------------

// IMAGE_SUBVOLUME

// optional int32 cornerVoxelIdxX = 1;
inline bool IMAGE_SUBVOLUME::has_cornervoxelidxx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_cornervoxelidxx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAGE_SUBVOLUME::clear_has_cornervoxelidxx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAGE_SUBVOLUME::clear_cornervoxelidxx() {
  cornervoxelidxx_ = 0;
  clear_has_cornervoxelidxx();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::cornervoxelidxx() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxX)
  return cornervoxelidxx_;
}
inline void IMAGE_SUBVOLUME::set_cornervoxelidxx(::google::protobuf::int32 value) {
  set_has_cornervoxelidxx();
  cornervoxelidxx_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxX)
}

// optional int32 cornerVoxelIdxY = 2;
inline bool IMAGE_SUBVOLUME::has_cornervoxelidxy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_cornervoxelidxy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAGE_SUBVOLUME::clear_has_cornervoxelidxy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAGE_SUBVOLUME::clear_cornervoxelidxy() {
  cornervoxelidxy_ = 0;
  clear_has_cornervoxelidxy();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::cornervoxelidxy() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxY)
  return cornervoxelidxy_;
}
inline void IMAGE_SUBVOLUME::set_cornervoxelidxy(::google::protobuf::int32 value) {
  set_has_cornervoxelidxy();
  cornervoxelidxy_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxY)
}

// optional int32 cornerVoxelIdxZ = 3;
inline bool IMAGE_SUBVOLUME::has_cornervoxelidxz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_cornervoxelidxz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAGE_SUBVOLUME::clear_has_cornervoxelidxz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAGE_SUBVOLUME::clear_cornervoxelidxz() {
  cornervoxelidxz_ = 0;
  clear_has_cornervoxelidxz();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::cornervoxelidxz() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxZ)
  return cornervoxelidxz_;
}
inline void IMAGE_SUBVOLUME::set_cornervoxelidxz(::google::protobuf::int32 value) {
  set_has_cornervoxelidxz();
  cornervoxelidxz_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.cornerVoxelIdxZ)
}

// optional int32 numVoxelX = 4;
inline bool IMAGE_SUBVOLUME::has_numvoxelx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_numvoxelx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAGE_SUBVOLUME::clear_has_numvoxelx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAGE_SUBVOLUME::clear_numvoxelx() {
  numvoxelx_ = 0;
  clear_has_numvoxelx();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::numvoxelx() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.numVoxelX)
  return numvoxelx_;
}
inline void IMAGE_SUBVOLUME::set_numvoxelx(::google::protobuf::int32 value) {
  set_has_numvoxelx();
  numvoxelx_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.numVoxelX)
}

// optional int32 numVoxelY = 5;
inline bool IMAGE_SUBVOLUME::has_numvoxely() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_numvoxely() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAGE_SUBVOLUME::clear_has_numvoxely() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAGE_SUBVOLUME::clear_numvoxely() {
  numvoxely_ = 0;
  clear_has_numvoxely();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::numvoxely() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.numVoxelY)
  return numvoxely_;
}
inline void IMAGE_SUBVOLUME::set_numvoxely(::google::protobuf::int32 value) {
  set_has_numvoxely();
  numvoxely_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.numVoxelY)
}

// optional int32 numVoxelZ = 6;
inline bool IMAGE_SUBVOLUME::has_numvoxelz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMAGE_SUBVOLUME::set_has_numvoxelz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMAGE_SUBVOLUME::clear_has_numvoxelz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMAGE_SUBVOLUME::clear_numvoxelz() {
  numvoxelz_ = 0;
  clear_has_numvoxelz();
}
inline ::google::protobuf::int32 IMAGE_SUBVOLUME::numvoxelz() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.SUBVOLUME.numVoxelZ)
  return numvoxelz_;
}
inline void IMAGE_SUBVOLUME::set_numvoxelz(::google::protobuf::int32 value) {
  set_has_numvoxelz();
  numvoxelz_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.SUBVOLUME.numVoxelZ)
}

// -------------------------------------------------------------------

// IMAGE_imageArray

// optional bytes dataRed = 1;
inline bool IMAGE_imageArray::has_datared() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAGE_imageArray::set_has_datared() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAGE_imageArray::clear_has_datared() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAGE_imageArray::clear_datared() {
  datared_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datared();
}
inline const ::std::string& IMAGE_imageArray::datared() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.imageArray.dataRed)
  return datared_.GetNoArena();
}
inline void IMAGE_imageArray::set_datared(const ::std::string& value) {
  set_has_datared();
  datared_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.imageArray.dataRed)
}
#if LANG_CXX11
inline void IMAGE_imageArray::set_datared(::std::string&& value) {
  set_has_datared();
  datared_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.IMAGE.imageArray.dataRed)
}
#endif
inline void IMAGE_imageArray::set_datared(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_datared();
  datared_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.IMAGE.imageArray.dataRed)
}
inline void IMAGE_imageArray::set_datared(const void* value, size_t size) {
  set_has_datared();
  datared_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.IMAGE.imageArray.dataRed)
}
inline ::std::string* IMAGE_imageArray::mutable_datared() {
  set_has_datared();
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.imageArray.dataRed)
  return datared_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMAGE_imageArray::release_datared() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.imageArray.dataRed)
  clear_has_datared();
  return datared_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMAGE_imageArray::set_allocated_datared(::std::string* datared) {
  if (datared != NULL) {
    set_has_datared();
  } else {
    clear_has_datared();
  }
  datared_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datared);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.imageArray.dataRed)
}

// optional bytes dataGreen = 2;
inline bool IMAGE_imageArray::has_datagreen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAGE_imageArray::set_has_datagreen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAGE_imageArray::clear_has_datagreen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAGE_imageArray::clear_datagreen() {
  datagreen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datagreen();
}
inline const ::std::string& IMAGE_imageArray::datagreen() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.imageArray.dataGreen)
  return datagreen_.GetNoArena();
}
inline void IMAGE_imageArray::set_datagreen(const ::std::string& value) {
  set_has_datagreen();
  datagreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.imageArray.dataGreen)
}
#if LANG_CXX11
inline void IMAGE_imageArray::set_datagreen(::std::string&& value) {
  set_has_datagreen();
  datagreen_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.IMAGE.imageArray.dataGreen)
}
#endif
inline void IMAGE_imageArray::set_datagreen(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_datagreen();
  datagreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.IMAGE.imageArray.dataGreen)
}
inline void IMAGE_imageArray::set_datagreen(const void* value, size_t size) {
  set_has_datagreen();
  datagreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.IMAGE.imageArray.dataGreen)
}
inline ::std::string* IMAGE_imageArray::mutable_datagreen() {
  set_has_datagreen();
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.imageArray.dataGreen)
  return datagreen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMAGE_imageArray::release_datagreen() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.imageArray.dataGreen)
  clear_has_datagreen();
  return datagreen_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMAGE_imageArray::set_allocated_datagreen(::std::string* datagreen) {
  if (datagreen != NULL) {
    set_has_datagreen();
  } else {
    clear_has_datagreen();
  }
  datagreen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datagreen);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.imageArray.dataGreen)
}

// optional bytes dataBlue = 3;
inline bool IMAGE_imageArray::has_datablue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAGE_imageArray::set_has_datablue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAGE_imageArray::clear_has_datablue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAGE_imageArray::clear_datablue() {
  datablue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datablue();
}
inline const ::std::string& IMAGE_imageArray::datablue() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.imageArray.dataBlue)
  return datablue_.GetNoArena();
}
inline void IMAGE_imageArray::set_datablue(const ::std::string& value) {
  set_has_datablue();
  datablue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.imageArray.dataBlue)
}
#if LANG_CXX11
inline void IMAGE_imageArray::set_datablue(::std::string&& value) {
  set_has_datablue();
  datablue_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.IMAGE.imageArray.dataBlue)
}
#endif
inline void IMAGE_imageArray::set_datablue(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_datablue();
  datablue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.IMAGE.imageArray.dataBlue)
}
inline void IMAGE_imageArray::set_datablue(const void* value, size_t size) {
  set_has_datablue();
  datablue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.IMAGE.imageArray.dataBlue)
}
inline ::std::string* IMAGE_imageArray::mutable_datablue() {
  set_has_datablue();
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.imageArray.dataBlue)
  return datablue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMAGE_imageArray::release_datablue() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.imageArray.dataBlue)
  clear_has_datablue();
  return datablue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMAGE_imageArray::set_allocated_datablue(::std::string* datablue) {
  if (datablue != NULL) {
    set_has_datablue();
  } else {
    clear_has_datablue();
  }
  datablue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datablue);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.imageArray.dataBlue)
}

// optional bytes data = 4;
inline bool IMAGE_imageArray::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAGE_imageArray::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAGE_imageArray::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAGE_imageArray::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& IMAGE_imageArray::data() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.imageArray.data)
  return data_.GetNoArena();
}
inline void IMAGE_imageArray::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.imageArray.data)
}
#if LANG_CXX11
inline void IMAGE_imageArray::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.IMAGE.imageArray.data)
}
#endif
inline void IMAGE_imageArray::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.IMAGE.imageArray.data)
}
inline void IMAGE_imageArray::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.IMAGE.imageArray.data)
}
inline ::std::string* IMAGE_imageArray::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.imageArray.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMAGE_imageArray::release_data() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.imageArray.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMAGE_imageArray::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.imageArray.data)
}

// -------------------------------------------------------------------

// IMAGE

// optional .SIMPLE.IMAGE.METRICS metric = 1;
inline bool IMAGE::has_metric() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAGE::set_has_metric() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAGE::clear_has_metric() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAGE::clear_metric() {
  if (metric_ != NULL) metric_->::SIMPLE::IMAGE_METRICS::Clear();
  clear_has_metric();
}
inline const ::SIMPLE::IMAGE_METRICS& IMAGE::metric() const {
  const ::SIMPLE::IMAGE_METRICS* p = metric_;
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.metric)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::IMAGE_METRICS*>(
      &::SIMPLE::_IMAGE_METRICS_default_instance_);
}
inline ::SIMPLE::IMAGE_METRICS* IMAGE::mutable_metric() {
  set_has_metric();
  if (metric_ == NULL) {
    metric_ = new ::SIMPLE::IMAGE_METRICS;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.metric)
  return metric_;
}
inline ::SIMPLE::IMAGE_METRICS* IMAGE::release_metric() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.metric)
  clear_has_metric();
  ::SIMPLE::IMAGE_METRICS* temp = metric_;
  metric_ = NULL;
  return temp;
}
inline void IMAGE::set_allocated_metric(::SIMPLE::IMAGE_METRICS* metric) {
  delete metric_;
  metric_ = metric;
  if (metric) {
    set_has_metric();
  } else {
    clear_has_metric();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.metric)
}

// optional .SIMPLE.IMAGE.SUBVOLUME subvolume = 2;
inline bool IMAGE::has_subvolume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAGE::set_has_subvolume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAGE::clear_has_subvolume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAGE::clear_subvolume() {
  if (subvolume_ != NULL) subvolume_->::SIMPLE::IMAGE_SUBVOLUME::Clear();
  clear_has_subvolume();
}
inline const ::SIMPLE::IMAGE_SUBVOLUME& IMAGE::subvolume() const {
  const ::SIMPLE::IMAGE_SUBVOLUME* p = subvolume_;
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.subvolume)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::IMAGE_SUBVOLUME*>(
      &::SIMPLE::_IMAGE_SUBVOLUME_default_instance_);
}
inline ::SIMPLE::IMAGE_SUBVOLUME* IMAGE::mutable_subvolume() {
  set_has_subvolume();
  if (subvolume_ == NULL) {
    subvolume_ = new ::SIMPLE::IMAGE_SUBVOLUME;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.subvolume)
  return subvolume_;
}
inline ::SIMPLE::IMAGE_SUBVOLUME* IMAGE::release_subvolume() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.subvolume)
  clear_has_subvolume();
  ::SIMPLE::IMAGE_SUBVOLUME* temp = subvolume_;
  subvolume_ = NULL;
  return temp;
}
inline void IMAGE::set_allocated_subvolume(::SIMPLE::IMAGE_SUBVOLUME* subvolume) {
  delete subvolume_;
  subvolume_ = subvolume;
  if (subvolume) {
    set_has_subvolume();
  } else {
    clear_has_subvolume();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.subvolume)
}

// optional bool existSUBVOLUME = 3;
inline bool IMAGE::has_existsubvolume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAGE::set_has_existsubvolume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAGE::clear_has_existsubvolume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAGE::clear_existsubvolume() {
  existsubvolume_ = false;
  clear_has_existsubvolume();
}
inline bool IMAGE::existsubvolume() const {
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.existSUBVOLUME)
  return existsubvolume_;
}
inline void IMAGE::set_existsubvolume(bool value) {
  set_has_existsubvolume();
  existsubvolume_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.IMAGE.existSUBVOLUME)
}

// optional .SIMPLE.IMAGE.imageArray imageData = 4;
inline bool IMAGE::has_imagedata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAGE::set_has_imagedata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAGE::clear_has_imagedata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAGE::clear_imagedata() {
  if (imagedata_ != NULL) imagedata_->::SIMPLE::IMAGE_imageArray::Clear();
  clear_has_imagedata();
}
inline const ::SIMPLE::IMAGE_imageArray& IMAGE::imagedata() const {
  const ::SIMPLE::IMAGE_imageArray* p = imagedata_;
  // @@protoc_insertion_point(field_get:SIMPLE.IMAGE.imageData)
  return p != NULL ? *p : *reinterpret_cast<const ::SIMPLE::IMAGE_imageArray*>(
      &::SIMPLE::_IMAGE_imageArray_default_instance_);
}
inline ::SIMPLE::IMAGE_imageArray* IMAGE::mutable_imagedata() {
  set_has_imagedata();
  if (imagedata_ == NULL) {
    imagedata_ = new ::SIMPLE::IMAGE_imageArray;
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.IMAGE.imageData)
  return imagedata_;
}
inline ::SIMPLE::IMAGE_imageArray* IMAGE::release_imagedata() {
  // @@protoc_insertion_point(field_release:SIMPLE.IMAGE.imageData)
  clear_has_imagedata();
  ::SIMPLE::IMAGE_imageArray* temp = imagedata_;
  imagedata_ = NULL;
  return temp;
}
inline void IMAGE::set_allocated_imagedata(::SIMPLE::IMAGE_imageArray* imagedata) {
  delete imagedata_;
  imagedata_ = imagedata;
  if (imagedata) {
    set_has_imagedata();
  } else {
    clear_has_imagedata();
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.IMAGE.imageData)
}

// -------------------------------------------------------------------

// GENERIC

// optional bool basicBool = 1;
inline bool GENERIC::has_basicbool() const {
  return data_case() == kBasicBool;
}
inline void GENERIC::set_has_basicbool() {
  _oneof_case_[0] = kBasicBool;
}
inline void GENERIC::clear_basicbool() {
  if (has_basicbool()) {
    data_.basicbool_ = false;
    clear_has_data();
  }
}
inline bool GENERIC::basicbool() const {
  // @@protoc_insertion_point(field_get:SIMPLE.GENERIC.basicBool)
  if (has_basicbool()) {
    return data_.basicbool_;
  }
  return false;
}
inline void GENERIC::set_basicbool(bool value) {
  if (!has_basicbool()) {
    clear_data();
    set_has_basicbool();
  }
  data_.basicbool_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicBool)
}

// optional int32 basicInt = 2;
inline bool GENERIC::has_basicint() const {
  return data_case() == kBasicInt;
}
inline void GENERIC::set_has_basicint() {
  _oneof_case_[0] = kBasicInt;
}
inline void GENERIC::clear_basicint() {
  if (has_basicint()) {
    data_.basicint_ = 0;
    clear_has_data();
  }
}
inline ::google::protobuf::int32 GENERIC::basicint() const {
  // @@protoc_insertion_point(field_get:SIMPLE.GENERIC.basicInt)
  if (has_basicint()) {
    return data_.basicint_;
  }
  return 0;
}
inline void GENERIC::set_basicint(::google::protobuf::int32 value) {
  if (!has_basicint()) {
    clear_data();
    set_has_basicint();
  }
  data_.basicint_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicInt)
}

// optional float basicFloat = 3;
inline bool GENERIC::has_basicfloat() const {
  return data_case() == kBasicFloat;
}
inline void GENERIC::set_has_basicfloat() {
  _oneof_case_[0] = kBasicFloat;
}
inline void GENERIC::clear_basicfloat() {
  if (has_basicfloat()) {
    data_.basicfloat_ = 0;
    clear_has_data();
  }
}
inline float GENERIC::basicfloat() const {
  // @@protoc_insertion_point(field_get:SIMPLE.GENERIC.basicFloat)
  if (has_basicfloat()) {
    return data_.basicfloat_;
  }
  return 0;
}
inline void GENERIC::set_basicfloat(float value) {
  if (!has_basicfloat()) {
    clear_data();
    set_has_basicfloat();
  }
  data_.basicfloat_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicFloat)
}

// optional double basicDouble = 4;
inline bool GENERIC::has_basicdouble() const {
  return data_case() == kBasicDouble;
}
inline void GENERIC::set_has_basicdouble() {
  _oneof_case_[0] = kBasicDouble;
}
inline void GENERIC::clear_basicdouble() {
  if (has_basicdouble()) {
    data_.basicdouble_ = 0;
    clear_has_data();
  }
}
inline double GENERIC::basicdouble() const {
  // @@protoc_insertion_point(field_get:SIMPLE.GENERIC.basicDouble)
  if (has_basicdouble()) {
    return data_.basicdouble_;
  }
  return 0;
}
inline void GENERIC::set_basicdouble(double value) {
  if (!has_basicdouble()) {
    clear_data();
    set_has_basicdouble();
  }
  data_.basicdouble_ = value;
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicDouble)
}

// optional string basicString = 5;
inline bool GENERIC::has_basicstring() const {
  return data_case() == kBasicString;
}
inline void GENERIC::set_has_basicstring() {
  _oneof_case_[0] = kBasicString;
}
inline void GENERIC::clear_basicstring() {
  if (has_basicstring()) {
    data_.basicstring_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_data();
  }
}
inline const ::std::string& GENERIC::basicstring() const {
  // @@protoc_insertion_point(field_get:SIMPLE.GENERIC.basicString)
  if (has_basicstring()) {
    return data_.basicstring_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void GENERIC::set_basicstring(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicString)
  if (!has_basicstring()) {
    clear_data();
    set_has_basicstring();
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.basicstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicString)
}
#if LANG_CXX11
inline void GENERIC::set_basicstring(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SIMPLE.GENERIC.basicString)
  if (!has_basicstring()) {
    clear_data();
    set_has_basicstring();
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.basicstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SIMPLE.GENERIC.basicString)
}
#endif
inline void GENERIC::set_basicstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_basicstring()) {
    clear_data();
    set_has_basicstring();
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.basicstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SIMPLE.GENERIC.basicString)
}
inline void GENERIC::set_basicstring(const char* value, size_t size) {
  if (!has_basicstring()) {
    clear_data();
    set_has_basicstring();
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.basicstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SIMPLE.GENERIC.basicString)
}
inline ::std::string* GENERIC::mutable_basicstring() {
  if (!has_basicstring()) {
    clear_data();
    set_has_basicstring();
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SIMPLE.GENERIC.basicString)
  return data_.basicstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GENERIC::release_basicstring() {
  // @@protoc_insertion_point(field_release:SIMPLE.GENERIC.basicString)
  if (has_basicstring()) {
    clear_has_data();
    return data_.basicstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void GENERIC::set_allocated_basicstring(::std::string* basicstring) {
  if (!has_basicstring()) {
    data_.basicstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_data();
  if (basicstring != NULL) {
    set_has_basicstring();
    data_.basicstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        basicstring);
  }
  // @@protoc_insertion_point(field_set_allocated:SIMPLE.GENERIC.basicString)
}

inline bool GENERIC::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void GENERIC::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline GENERIC::DataCase GENERIC::data_case() const {
  return GENERIC::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SIMPLE

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SIMPLE::IMAGE_METRICS_COStype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SIMPLE::IMAGE_METRICS_COStype>() {
  return ::SIMPLE::IMAGE_METRICS_COStype_descriptor();
}
template <> struct is_proto_enum< ::SIMPLE::IMAGE_METRICS_dataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SIMPLE::IMAGE_METRICS_dataType>() {
  return ::SIMPLE::IMAGE_METRICS_dataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SIMPLE_2eproto__INCLUDED
